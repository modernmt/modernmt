View an ActiveX Control's About Box
To view an About box showing version and copyright information for an ActiveX control , click the About property box in the Microsoft Access property sheet . Then click the Build button to the right of the property box.
The About box is not available for ActiveX controls on a data access page .
The ActiveX Control's Custom Properties Dialog Box
When setting the properties of an ActiveX control , you may need or prefer to use the control's custom properties dialog box . This custom properties dialog box provides an alternative to the list of properties in the Microsoft Access property sheet for setting ActiveX control properties in Design view .
When setting the properties of an ActiveX control , you may need or prefer to use the control's custom properties dialog box .
This custom properties dialog box provides an alternative to the list of properties in the Microsoft Access property sheet for setting ActiveX control properties in Design view .
This information only applies to ActiveX controls in a Microsoft Access database (.mdb) environment.
Two Ways to Set Properties
The reason for the custom properties dialog box is that not all applications that use ActiveX controls provide a property sheet like the one in Microsoft Access.
The custom properties dialog box provides an interface for setting key control properties regardless of the interface supplied by the hosting application.
For some ActiveX control properties, you can choose either of these two locations to set the property:
The Microsoft Access property sheet.
The ActiveX control's custom properties dialog box.
In some cases, the custom properties dialog box is the only way to set a property in Design view. This is usually the situation when the interface needed to set a property doesn't work inside the Microsoft Access property sheet. For example, the GridFont property for the Calendar control has a number of arguments; you can't set more than one argument per property in the Microsoft Access property sheet.
Finding the Custom Properties Dialog Box
Not all ActiveX controls provide a custom properties dialog box. To see whether a control provides this custom properties dialog box, look for the Custom property in the Microsoft Access property sheet for this control. If the list of properties contains the name Custom , then the control provides the custom properties dialog box.
Not all ActiveX controls provide a custom properties dialog box.
See Elements of Run-Time Error Handling for more information about handling run-time errors in VBA.
If the list of properties contains the name Custom , then the control provides the custom properties dialog box.
Using the Custom Properties Dialog Box
After you click the Custom property box in the Microsoft Access property sheet, click the Build button to the right of the property box to display the control's custom properties dialog box, often presented as a tabbed dialog box. Choose the tab that contains the interface for setting the properties that you want to set.
The MacroError object does not contain information about run-time errors that occur when running Visual Basic for Applications (VBA) code. See Elements of Run-Time Error Handling for more information about handling run-time errors in VBA.
The MacroError object does not contain information about run-time errors that occur when running Visual Basic for Applications (VBA) code.
After you click the Custom property box in the Microsoft Access property sheet, click the Build button to the right of the property box to display the control's custom properties dialog box, often presented as a tabbed dialog box.
The MacroError object contains information about only one error at a time. If more than one error has occurred in a macro, the MacroError object contains information about only the last one.
The MacroError object contains information about only one error at a time.
Choose the tab that contains the interface for setting the properties that you want to set.
After you make changes on one tab, you can often apply those changes immediately by clicking the Apply button (if provided). You can click other tabs to set other properties as needed. To approve all changes made in the custom properties dialog box, click the OK button. To return to the Microsoft Access property sheet without changing any property settings, click the Cancel button.
After you make changes on one tab, you can often apply those changes immediately by clicking the Apply button (if provided).
You can click other tabs to set other properties as needed.
To approve all changes made in the custom properties dialog box, click the OK button.
To return to the Microsoft Access property sheet without changing any property settings, click the Cancel button.
You can also view the custom properties dialog box by clicking the Properties subcommand of the ActiveX control Object command (for example, Calendar Control Object ) on the Edit menu, or by clicking this same subcommand on the shortcut menu for the ActiveX control. In addition, some properties in the Microsoft Access property sheet for the ActiveX control, like the GridFontColor property of the Calendar control, have a Build button to the right of the property box. When you click the Build button, the custom properties dialog box is displayed, with the appropriate tab selected (for example, Colors ).
You can also view the custom properties dialog box by clicking the Properties subcommand of the ActiveX control Object command (for example, Calendar Control Object ) on the Edit menu, or by clicking this same subcommand on the shortcut menu for the ActiveX control.
In addition, some properties in the Microsoft Access property sheet for the ActiveX control, like the GridFontColor property of the Calendar control, have a Build button to the right of the property box.
When you click the Build button, the custom properties dialog box is displayed, with the appropriate tab selected (for example, Colors ).
AccessObjectProperties Collection
The AccessObjectProperties collection contains all of the custom AccessObjectProperty objects of a specific instance of an object. These AccessObjectProperty objects (which are often just called properties) uniquely characterize that instance of the object.
Use the AccessObjectProperties collection in Visual Basic or in an expression to refer to properties of the CurrentProject , CodeProject , or AccessObject object. For example, you can enumerate the AccessObjectProperties collection to set or return the values of properties of an individual report.
The AccessObjectProperties collection contains all of the custom AccessObjectProperty objects of a specific instance of an object.
Use the AccessObjectProperties collection in Visual Basic or in an expression to refer to properties of the CurrentProject , CodeProject , or AccessObject object.
The AccessObjectProperties collection isn't accessible for objects derived from the CurrentData object (for example, CurrentData.AllTables!Table1 ). For objects derived in this manner, you can only access their built-in properties by direct calls to the desired property (for example, CurrentData.AllTables!Table1.Name ).
The AccessObjectProperties collection isn't accessible for objects derived from the CurrentData object (for example, CurrentData.AllTables!Table1 ).
For objects derived in this manner, you can only access their built-in properties by direct calls to the desired property (for example, CurrentData.AllTables!Table1.Name ).
To add a user-defined property to an existing instance of an object, first define its characteristics and add it to the collection with the Add method. Referencing a user-defined AccessObjectProperty object that has not yet been appended to an AccessObjectProperties collection will cause an error, as will appending a user-defined AccessObjectProperty object to an AccessObjectProperties collection containing an AccessObjectProperty object of the same name.
With the same syntax forms, you can also refer to the Value property of a AccessObjectProperty object. The context of the reference will determine whether you are referring to the AccessObjectProperty object itself or the Value property of the AccessObjectProperty object.
With the same syntax forms, you can also refer to the Value property of a AccessObjectProperty object.
CodeData , CodeProject , CurrentProject , and CurrentData objects
These AccessObjectProperty objects (which are often just called properties) uniquely characterize that instance of the object.
Using the AccessObjectProperties Collection
Use the AccessObjectProperties collection in Visual Basic or in an expression to refer to properties of the CurrentProject , CodeProject , or AccessObject object. For example, you can enumerate the AccessObjectProperties collection to set or return the values of properties of an individual report.
Use the AccessObjectProperties collection in Visual Basic or in an expression to refer to properties of the CurrentProject , CodeProject , or AccessObject object.
For example, you can enumerate the AccessObjectProperties collection to set or return the values of properties of an individual report.
The AccessObjectProperties collection isn't accessible for objects derived from the CurrentData object (for example, CurrentData.AllTables!Table1). For objects derived in this manner, you can only access their built-in properties by direct calls to the desired property (for example, CurrentData.AllTables!Table1.Name).
The AccessObjectProperties collection isn't accessible for objects derived from the CurrentData object (for example, CurrentData.AllTables!Table1).
For objects derived in this manner, you can only access their built-in properties by direct calls to the desired property (for example, CurrentData.AllTables!Table1.Name).
To add a user-defined property to an existing instance of an object, first define its characteristics and add it to the collection with the Add method. Referencing a user-defined AccessObjectProperty object that has not yet been appended to an AccessObjectProperties collection will cause an error, as will appending a user-defined AccessObjectProperty object to an AccessObjectProperties collection containing an AccessObjectProperty object of the same name.
You can use the Remove method to remove user-defined properties from the AccessObjectProperties collection.
The Name property, a String that uniquely identifies the property.
An AccessObject object refers to a particular Microsoft Access object .
A built-in or user-defined AccessObjectProperty object is associated only with the specific instance of an object. The property isn't defined for all instances of objects of the selected type.
A built-in or user-defined AccessObjectProperty object is associated only with the specific instance of an object.
The property isn't defined for all instances of objects of the selected type.
To refer to a built-in Property object in a collection by its ordinal number or by its Name property setting, use any of the following syntax forms:
object . Properties (0)
object . Properties ( name )
To refer to a built-in or user-defined AccessObjectProperty object in a collection by its ordinal number or by its Name property setting, use any of the following syntax forms:
With the same syntax forms, you can also refer to the Value property of a AccessObjectProperty object. The context of the reference will determine whether you are referring to the AccessObjectProperty object itself or the Value property of the AccessObjectProperty object.
With the same syntax forms, you can also refer to the Value property of a AccessObjectProperty object.
The context of the reference will determine whether you are referring to the AccessObjectProperty object itself or the Value property of the AccessObjectProperty object.
Properties in the AccessObjectProperties collection are not stored and can be lost when the object they are associated with is checked in or out using the Source Code Control add-in.
AllDataAccessPages Collection
The AllDataAccessPages collection contains an AccessObject object for each data access page in the CurrentProject or CodeProject object.
Although a Microsoft Access project (.adp) or Microsoft Access database (.mdb) can appear to contain data access pages, these pages are actually stored in files that are external to the project or database.
Using the AllDataAccessPages Collection
The CurrentProject or CodeProject object has an AllDataAccessPages collection containing AccessObject objects that describe instances of all data access pages. For example, you can enumerate the AllDataAccessPages collection in Visual Basic to set or return the values of properties of individual AccessObject objects in the collection.
The CurrentProject or CodeProject object has an AllDataAccessPages collection containing AccessObject objects that describe instances of all data access pages.
For example, you can enumerate the AllDataAccessPages collection in Visual Basic to set or return the values of properties of individual AccessObject objects in the collection.
The For Each...Next statement is useful for enumerating a collection.
You can refer to an individual AccessObject object in the AllDataAccessPages collection either by referring to the item by name, or by referring to its index within the collection. If you want to refer to a specific data access page in the AllDataAccessPages collection, it's better to refer to the item by name because the index may change.
You can refer to an individual AccessObject object in the AllDataAccessPages collection either by referring to the item by name, or by referring to its index within the collection.
If you want to refer to a specific data access page in the AllDataAccessPages collection, it's better to refer to the item by name because the index may change.
The AllDataAccessPages collection is indexed beginning with zero. If you refer to a data access page by its index, the first data access page is AllDataAccessPages(0), the second data access page is AllDataAccessPages(1), and so on.
The AllDataAccessPages collection is indexed beginning with zero.
If you refer to a data access page by its index, the first data access page is AllDataAccessPages(0), the second data access page is AllDataAccessPages(1), and so on.
To list all open data access pages in the database, use the IsLoaded property of each AccessObject object in the AllDataAccessPages collection. You can then use the Name property of each individual AccessObject object to return the name of a data access page.
To list all open data access pages in the database, use the IsLoaded property of each AccessObject object in the AllDataAccessPages collection.
You can then use the Name property of each individual AccessObject object to return the name of a data access page.
You can't add or delete an AccessObject object from the AllDataAccessPages collection.
The following example prints the name of each open AccessObject object in the AllDataAccessPages collection.
AllDatabaseDiagrams Collection
The AllDatabaseDiagrams collection contains an AccessObject for each database diagram in the CurrentData or CodeData object.
Using the AllDatabaseDiagrams Collection
The CurrentData or CodeData object has an AllDatabaseDiagrams collection containing AccessObject objects that describe instances of all database diagrams specified by CurrentData or CodeData . For example, you can enumerate the AllDatabaseDiagrams collection in Visual Basic to set or return the values of properties of individual AccessObject objects in the collection.
The CurrentData or CodeData object has an AllDatabaseDiagrams collection containing AccessObject objects that describe instances of all database diagrams specified by CurrentData or CodeData .
For example, you can enumerate the AllDatabaseDiagrams collection in Visual Basic to set or return the values of properties of individual AccessObject objects in the collection.
You can refer to an individual AccessObject object in the AllDatabaseDiagrams collection either by referring to the object by name, or by referring to its index within the collection. If you want to refer to a specific object in the AllDatabaseDiagrams collection, it's better to refer to the database diagram by name because a database diagram's collection index may change.
You can refer to an individual AccessObject object in the AllDatabaseDiagrams collection either by referring to the object by name, or by referring to its index within the collection.
If you want to refer to a specific object in the AllDatabaseDiagrams collection, it's better to refer to the database diagram by name because a database diagram's collection index may change.
The AllDatabaseDiagrams collection is indexed beginning with zero. If you refer to a database diagram by its index, the first database diagram is AllDatabaseDiagrams(0), the second database diagram is AllDatabaseDiagrams(1), and so on.
The AllDatabaseDiagrams collection is indexed beginning with zero.
If you refer to a database diagram by its index, the first database diagram is AllDatabaseDiagrams(0), the second database diagram is AllDatabaseDiagrams(1), and so on.
The AllDatabaseDiagrams collection only contains AccessObject objects within a Microsoft Access project (.adp). A Microsoft Access database (.mdb) does not contain any database diagrams.
The AllDatabaseDiagrams collection only contains AccessObject objects within a Microsoft Access project (.adp).
A Microsoft Access database (.mdb) does not contain any database diagrams.
To list all open database diagrams in the project, use the IsLoaded property of each AccessObject object in the AllDatabaseDiagrams collection. You can then use the Name property of each individual AccessObject object to return the name of a database diagram.
The AllQueries collection only contains AccessObject objects within a Microsoft Access database . A Microsoft Access project (.adp) does not contain any macros, see the AllViews collection.
To list all open queries in the database, use the IsLoaded property of each AccessObject object in the AllQueries collection. You can then use the Name property of each individual AccessObject object to return the name of a query
You can then use the Name property of each individual AccessObject object to return the name of a query
The AllStoredProcedures collection only contains AccessObject objects within a Microsoft Access project (.adp). A Microsoft Access database does not contain any stored procedures, see the AllMacros collection.
To list all open database diagrams in the project, use the IsLoaded property of each AccessObject object in the AllDatabaseDiagrams collection.
When you select or clear a check box that's bound to a Yes/No field, Microsoft Access displays the value in the underlying table according to the field's Format property (Yes/No, True/False, or On/Off).
You can then use the Name property of each individual AccessObject object to return the name of a database diagram.
You can't add or delete an AccessObject object from the AllDatabaseDiagrams collection.
The following example prints the name of each open AccessObject object in the AllDatabaseDiagrams collection.
AllForms Collection
The AllForms collection contains an AccessObject object for each form in the CurrentProject or CodeProject object.
Using the AllForms Collection
The CurrentProject and CodeProject object has an AllForms collection containing AccessObject objects that describe instances of all the forms in the database. For example, you can enumerate the AllForms collection in Visual Basic to set or return the values of properties of individual AccessObject objects in the collection.
The CurrentProject and CodeProject object has an AllForms collection containing AccessObject objects that describe instances of all the forms in the database.
For example, you can enumerate the AllForms collection in Visual Basic to set or return the values of properties of individual AccessObject objects in the collection.
You can refer to an individual AccessObject object in the AllForms collection either by referring to the object by name, or by referring to its index within the collection. If you want to refer to a specific object in the AllForms collection, it's better to refer to the form by name because a form's collection index may change.
You can refer to an individual AccessObject object in the AllForms collection either by referring to the object by name, or by referring to its index within the collection.
If you want to refer to a specific object in the AllForms collection, it's better to refer to the form by name because a form's collection index may change.
The AllForms collection is indexed beginning with zero. If you refer to a form by its index, the first form is AllForms(0), the second form is AllForms(1), and so on.
The AllForms collection is indexed beginning with zero.
If you refer to a form by its index, the first form is AllForms(0), the second form is AllForms(1), and so on.
To list all open forms in the database, use the IsLoaded property of each AccessObject object in the AllForms collection. You can then use the Name property of each individual AccessObject object to return the name of a form.
To list all open forms in the database, use the IsLoaded property of each AccessObject object in the AllForms collection.
You can then use the Name property of each individual AccessObject object to return the name of a form.
You can't add or delete an AccessObject object from the AllForms collection.
Check Box Control
The following example prints the name of each open AccessObject object in the AllForms collection.
AllMacros Collection
The AllMacros collection contains an AccessObject for each macro in the CurrentProject or CodeProject object.
Using the AllMacros Collection
The CurrentProject or CodeProject object has an AllMacros collection containing AccessObject objects that describe instances of all the macros specified by CurrentProject or CodeProject . For example, you can enumerate the AllMacros collection in Visual Basic to set or return the values of properties of individual AccessObject objects in the collection.
The CurrentProject or CodeProject object has an AllMacros collection containing AccessObject objects that describe instances of all the macros specified by CurrentProject or CodeProject .
For example, you can enumerate the AllMacros collection in Visual Basic to set or return the values of properties of individual AccessObject objects in the collection.
You can refer to an individual AccessObject object in the AllMacros collection either by referring to the object by name, or by referring to its index within the collection. If you want to refer to a specific object in the AllMacros collection, it's better to refer to the macro by name because a macro's collection index may change.
You can refer to an individual AccessObject object in the AllMacros collection either by referring to the object by name, or by referring to its index within the collection.
If you want to refer to a specific object in the AllMacros collection, it's better to refer to the macro by name because a macro's collection index may change.
The AllMacros collection is indexed beginning with zero. If you refer to a macro by its index, the first macro is AllMacros(0), the second macro is AllMacros(1), and so on.
The AllMacros collection is indexed beginning with zero.
If you refer to a macro by its index, the first macro is AllMacros(0), the second macro is AllMacros(1), and so on.
To list all open macros in the database, use the IsLoaded property of each AccessObject object in the AllMacros collection. You can then use the Name property of each individual AccessObject object to return the name of a macro.
To list all open macros in the database, use the IsLoaded property of each AccessObject object in the AllMacros collection.
You can then use the Name property of each individual AccessObject object to return the name of a macro.
You can't add or delete an AccessObject object from the AllMacros collection.
A bound control is a control on a form or report that gets its contents from a field in the underlying table, query, or SQL statement. (The control's ControlSource property is set to a field name in the table, query, or SQL statement.) For example, a text box that displays an employee's last name is bound to the LastName field in the Employees table.
The following example prints the name of each open AccessObject object in the AllMacros collection.
AllModules Collection
The AllModules collection contains an AccessObject of each module in the CurrentProject or CodeProject object.
Using the AllModules Collection
The CurrentProject or CodeProject object has an AllModules collection containing AccessObject objects that describe instances of all the Module objects specified by CurrentProject or CodeProject . For example, you can enumerate the AllModules collection in Visual Basic to set or return the values of properties of individual AccessObject objects in the collection.
The CurrentProject or CodeProject object has an AllModules collection containing AccessObject objects that describe instances of all the Module objects specified by CurrentProject or CodeProject .
For example, you can enumerate the AllModules collection in Visual Basic to set or return the values of properties of individual AccessObject objects in the collection.
You can refer to an individual AccessObject object in the AllModules collection either by referring to the object by name, or by referring to its index within the collection. If you want to refer to a specific object in the AllModules collection, it's better to refer to the module by name because a module's collection index may change.
You can refer to an individual AccessObject object in the AllModules collection either by referring to the object by name, or by referring to its index within the collection.
If you want to refer to a specific object in the AllModules collection, it's better to refer to the module by name because a module's collection index may change.
The AllModules collection is indexed beginning with zero. If you refer to a module by its index, the first module is AllModules(0), the second module is AllModules(1), and so on.
The AllModules collection is indexed beginning with zero.
If you refer to a module by its index, the first module is AllModules(0), the second module is AllModules(1), and so on.
To list all open modules in the database, use the IsLoaded property of each AccessObject object in the AllModules collection. You can then use the Name property of each individual AccessObject object to return the name of a module.
In addition to the built-in controls that appear in the toolbox, Microsoft Access supports ActiveX controls (formerly known as custom or OLE controls). An ActiveX control, like a built-in control, is an object that you place on a form to enable or enhance a user's interaction with an application. ActiveX controls have events and can be incorporated into other controls. These controls usually have an .dll or .ocx file name extension. The Calendar control is an example of an ActiveX control.
To list all open modules in the database, use the IsLoaded property of each AccessObject object in the AllModules collection.
You can then use the Name property of each individual AccessObject object to return the name of a module.
You can't add or delete an AccessObject object from the AllModules collection.
ActiveX Control
The following example prints the name of each open AccessObject object in the AllModules collection.
AllQueries Collection
The AllQueries collection contains an AccessObject for each query in the CurrentData or CodeData object.
Using the AllQueries Collection
The CurrentData or CodeData object has an AllQueries collection containing AccessObject objects that describe instances of all queries specified by CurrentData or CodeData . For example, you can enumerate the AllQueries collection in Visual Basic to set or return the values of properties of individual AccessObject objects in the collection.
The CurrentData or CodeData object has an AllQueries collection containing AccessObject objects that describe instances of all queries specified by CurrentData or CodeData .
For example, you can enumerate the AllQueries collection in Visual Basic to set or return the values of properties of individual AccessObject objects in the collection.
You can refer to an individual AccessObject object in the AllQueries collection either by referring to the object by name, or by referring to its index within the collection. If you want to refer to a specific object in the AllQueries collection, it's better to refer to the query by name because a query's collection index may change.
You can refer to an individual AccessObject object in the AllQueries collection either by referring to the object by name, or by referring to its index within the collection.
If you want to refer to a specific object in the AllQueries collection, it's better to refer to the query by name because a query's collection index may change.
The AllQueries collection is indexed beginning with zero. If you refer to a query by its index, the first query is AllQueries(0), the second query is AllQueries(1), and so on.
The AllQueries collection is indexed beginning with zero.
If you refer to a query by its index, the first query is AllQueries(0), the second query is AllQueries(1), and so on.
The AllQueries collection only contains AccessObject objects within a Microsoft Access database (.mdb). A Microsoft Access project (.adp) does not contain any macros, see the AllViews collection.
To list all open queries in the database, use the IsLoaded property of each AccessObject object in the AllQueries collection. You can then use the Name property of each individual AccessObject object to return the name of a query.
To list all open queries in the database, use the IsLoaded property of each AccessObject object in the AllQueries collection.
You can then use the Name property of each individual AccessObject object to return the name of a query.
You can't add or delete an AccessObject object from the AllQueries collection.
For example, you can use Null to set the DefaultValue property for a form control by using the following expression:
The following example prints the name of each open AccessObject object in the AllQueries collection.
AllReports Collection
The AllReports collection contains an AccessObject for each report in the CurrentProject or CodeProject object.
Using the AllReports Collection
The CurrentProject or CodeProject object has an AllReports collection containing AccessObject objects that describe instances of all the reports in the database. For example, you can enumerate the AllReports collection in Visual Basic to set or return the values of properties of individual AccessObject objects in the collection.
The CurrentProject or CodeProject object has an AllReports collection containing AccessObject objects that describe instances of all the reports in the database.
For example, you can enumerate the AllReports collection in Visual Basic to set or return the values of properties of individual AccessObject objects in the collection.
You can refer to an individual AccessObject object in the AllReports collection either by referring to the item by name, or by referring to its index within the collection. If you want to refer to a specific report in the AllReports collection, it's better to refer to the item by name because the index may change.
You can refer to an individual AccessObject object in the AllReports collection either by referring to the item by name, or by referring to its index within the collection.
If you want to refer to a specific report in the AllReports collection, it's better to refer to the item by name because the index may change.
The AllReports collection is indexed beginning with zero. If you refer to a report by its index, the first report is AllReports(0), the second report is AllReports(1), and so on.
The AllReports collection is indexed beginning with zero.
If you refer to a report by its index, the first report is AllReports(0), the second report is AllReports(1), and so on.
To list all open reports in the database, use the IsLoaded property of each AccessObject object in the AllReports collection. You can then use the Name property of each individual AccessObject object to return the name of a report.
To list all open reports in the database, use the IsLoaded property of each AccessObject object in the AllReports collection.
You can then use the Name property of each individual AccessObject object to return the name of a report.
Forms
You can use the system-defined constants True , False , and Null anywhere in Microsoft Access. For example, you can use True in the following macro condition expression. The condition is met if the Visible property setting for the Employees form equals True .
You can't add or delete a Report object from the Reports collection.
Automation with Microsoft Access
Microsoft Access is a COM component that supports Automation , formerly called OLE Automation. Microsoft Access supports Automation in two ways. From Microsoft Access, you can work with objects supplied by another component. Microsoft Access also supplies its objects to other COM components.
(The control's ControlSource property is set to a field name in the table, query, or SQL statement.)
Chart Control
You can't add or delete an AccessObject object from the AllReports collection.
To list all open stored procedures in the project, use the IsLoaded property of each AccessObject object in the AllStoredProcedures collection. You can then use the Name property of each individual AccessObject object to return the name of a stored procedure.
The AllViews collection contains an AccessObject for each view in the CurrentDa\ta or CodeData object.
The AllViews collection only contains AccessObject objects within a Microsoft Access project (.adp). A Microsoft Access database does not contain any views, see the AllQueries collection.
To list all open views in the project, use the IsLoaded property of each AccessObject object in the AllViews collection. You can then use the Name property of each individual AccessObject object to return the name of a view.
The tab control contains a Pages collection, which is a special type of Controls collection. The Pages collection contains Page objects. Page objects are also controls. The ControlType property constant for a Page control is acPage . A Page object, in turn, has its own Controls collection, which contains all the controls on an individual page.
The Pages collection contains Page objects.
Page objects are also controls.
The following example prints the name of each open AccessObject object in the AllReports collection.
AllStoredProcedures Collection
The AllStoredProcedures collection contains an AccessObject for each stored procedure in the CurrentData or CodeData object.
Using the AllStoredProcedures Collection
The CurrentData or CodeData object has an AllStoredProcedures collection containing AccessObject objects that describe instances of all stored procedures specified by CurrentData or CodeData . For example, you can enumerate the AllStoredProcedures collection in Visual Basic to set or return the values of properties of individual AccessObject objects in the collection.
The CurrentData or CodeData object has an AllStoredProcedures collection containing AccessObject objects that describe instances of all stored procedures specified by CurrentData or CodeData .
For example, you can enumerate the AllStoredProcedures collection in Visual Basic to set or return the values of properties of individual AccessObject objects in the collection.
You can refer to an individual AccessObject object in the AllStoredProcedures collection either by referring to the object by name, or by referring to its index within the collection. If you want to refer to a specific object in the AllStoredProcedures collection, it's better to refer to the stored procedures by name because a stored procedure's collection index may change.
You can refer to an individual AccessObject object in the AllStoredProcedures collection either by referring to the object by name, or by referring to its index within the collection.
If you want to refer to a specific object in the AllStoredProcedures collection, it's better to refer to the stored procedures by name because a stored procedure's collection index may change.
The AllStoredProcedures collection is indexed beginning with zero. If you refer to a stored procedure by its index, the first stored procedure is AllStoredProcedures(0), the second stored procedure is AllStoredProcedures(1), and so on.
The AllStoredProcedures collection is indexed beginning with zero.
If you refer to a stored procedure by its index, the first stored procedure is AllStoredProcedures(0), the second stored procedure is AllStoredProcedures(1), and so on.
The AllStoredProcedures collection only contains AccessObject objects within a Microsoft Access project (.adp). A Microsoft Access database (.mdb) does not contain any stored procedures, see the AllMacros collection.
To list all open stored procedures in the project, use the IsLoaded property of each AccessObject object in the AllStoredProcedures collection. You can then use the Name property of each individual AccessObject object to return the name of a stored procedure.
To list all open stored procedures in the project, use the IsLoaded property of each AccessObject object in the AllStoredProcedures collection.
For more information on adding references see Set References to Type Libraries .
You can then use the Name property of each individual AccessObject object to return the name of a stored procedure.
You can't add or delete an AccessObject object from the AllStoredProcedures collection.
The following example prints the name of each open AccessObject object in the AllProcedures collection.
AllTables Collection
The AllTables collection contains an AccessObject for each table in the CurrentData or CodeData object.
Using the AllTables Collection
The CurrentData or CodeData object has an AllTables collection containing AccessObject objects that describe instances of all tables specified by CurrentData or CodeData . For example, you can enumerate the AllTables collection in Visual Basic to set or return the values of properties of individual AccessObject objects in the collection.
The CurrentData or CodeData object has an AllTables collection containing AccessObject objects that describe instances of all tables specified by CurrentData or CodeData .
For example, you can enumerate the AllTables collection in Visual Basic to set or return the values of properties of individual AccessObject objects in the collection.
You can refer to an individual AccessObject object in the AllTables collection either by referring to the object by name, or by referring to its index within the collection. If you want to refer to a specific object in the AllTables collection, it's better to refer to the table by name because a table's collection index may change.
You can refer to an individual AccessObject object in the AllTables collection either by referring to the object by name, or by referring to its index within the collection.
If you want to refer to a specific object in the AllTables collection, it's better to refer to the table by name because a table's collection index may change.
The AllTables collection is indexed beginning with zero. If you refer to a table by its index, the first table is AllTables(0), the second table is AllTables(1), and so on.
The AllTables collection is indexed beginning with zero.
If you refer to a table by its index, the first table is AllTables(0), the second table is AllTables(1), and so on.
To list all open tables in the database, use the IsLoaded property of each AccessObject object in the AllTables collection. You can then use the Name property of each individual AccessObject object to return the name of a table.
To list all open tables in the database, use the IsLoaded property of each AccessObject object in the AllTables collection.
You can then use the Name property of each individual AccessObject object to return the name of a table.
The set of enumerated constants for each method, function, or property argument has a name, which is displayed in the syntax line for the method, function, or property in the Module window when the Auto Quick Info option is selected in the Editor tab of the Options dialog box, available by clicking Options on the Tools menu. (For property settings, the name isn't displayed, just the list of constants.) For example, the syntax line for the OpenForm method of the DoCmd object shows [View As AcFormView = acNormal] for the view argument of this method. AcFormView is the name of this set of enumerated constants, and acNormal is the default setting for the argument. The Object Browser also lists the names of the sets of enumerated constants in the Classes box and lists the intrinsic constants contained in each of these sets in the Members Of box.
The set of enumerated constants for each method, function, or property argument has a name, which is displayed in the syntax line for the method, function, or property in the Module window when the Auto Quick Info option is selected in the Editor tab of the Options dialog box, available by clicking Options on the Tools menu.
For example, the syntax line for the OpenForm method of the DoCmd object shows [View As AcFormView = acNormal] for the view argument of this method.
You can't add or delete an AccessObject object from the AllTables collection.
Sample Functions that perform operations that are compatible with byte processing functions of 16-bit versions (Differences in String Function Operations)
The following example prints the name of each open AccessObject object in the AllTables collection.
AllViews Collection
The AllViews collection contains an AccessObject for each view in the CurrentData or CodeData object.
Using the AllViews Collection
The CurrentData or CodeData object has an AllViews collection containing AccessObject objects that describe instances of all views specified by CurrentData or CodeData . For example, you can enumerate the AllViews collection in Visual Basic to set or return the values of properties of individual AccessObject objects in the collection.
The CurrentData or CodeData object has an AllViews collection containing AccessObject objects that describe instances of all views specified by CurrentData or CodeData .
For example, you can enumerate the AllViews collection in Visual Basic to set or return the values of properties of individual AccessObject objects in the collection.
You can refer to an individual AccessObject object in the AllViews collection either by referring to the object by name, or by referring to its index within the collection. If you want to refer to a specific object in the AllViews collection, it's better to refer to the view by name because a view's collection index may change.
You can refer to an individual AccessObject object in the AllViews collection either by referring to the object by name, or by referring to its index within the collection.
If you want to refer to a specific object in the AllViews collection, it's better to refer to the view by name because a view's collection index may change.
The AllViews collection is indexed beginning with zero. If you refer to a view by its index, the first view is AllViews(0), the second table is AllViews(1), and so on.
The AllViews collection is indexed beginning with zero.
If you refer to a view by its index, the first view is AllViews(0), the second table is AllViews(1), and so on.
The AllViews collection only contains AccessObject objects within a Microsoft Access project (.adp). A Microsoft Access database (.mdb) does not contain any views, see the AllQueries collection.
To list all open views in the project, use the IsLoaded property of each AccessObject object in the AllViews collection. You can then use the Name property of each individual AccessObject object to return the name of a view.
To list all open views in the project, use the IsLoaded property of each AccessObject object in the AllViews collection.
You can then use the Name property of each individual AccessObject object to return the name of a view.
You can't add or delete an AccessObject object from the AllViews collection.
Processing ANSI String Bytes (Differences in String Function Operations)
The following example prints the name of each open AccessObject object in the AllViews collection.
Controls Collection
The Controls collection contains all of the controls on a form, report, or subform, within another control, or attached to another control. The Controls collection is a member of a Form , Report , and SubForm objects.
The Controls collection contains all of the controls on a form, report, or subform, within another control, or attached to another control.
The Controls collection is a member of a Form , Report , and SubForm objects.
Using the Controls Collection
You can enumerate individual controls, count them, and set their properties in the Controls collection. For example, you can enumerate the Controls collection of a particular form and set the Height property of each control to a specified value.
You can enumerate individual controls, count them, and set their properties in the Controls collection.
For example, you can enumerate the Controls collection of a particular form and set the Height property of each control to a specified value.
It is faster to refer to the Controls collection implicitly, as in the following examples, which refer to a control called NewData on a form named OrderForm. Of the following syntax examples, Me!NewData is the fastest way to refer to the control.
It is faster to refer to the Controls collection implicitly, as in the following examples, which refer to a control called NewData on a form named OrderForm.
Of the following syntax examples, Me!NewData is the fastest way to refer to the control.
You can also refer to an individual control by referring explicitly to the Controls collection.
Additionally, you can refer to a control by its index in the collection. The Controls collection is indexed beginning with zero.
Additionally, you can refer to a control by its index in the collection.
The Controls collection is indexed beginning with zero.
You can use the Me keyword to represent a form or report within code only if you're referring to the form or report from code within the form module or report module . If you're referring to a form or report from a standard module or a different form's or report's module, you must use the full reference to the form or report.
You can use the Me keyword to represent a form or report within code only if you're referring to the form or report from code within the form module or report module .
If you're referring to a form or report from a standard module or a different form's or report's module, you must use the full reference to the form or report.
To work with the controls on a section of a form or report, use the Section property to return a reference to a Section object. Then refer to the Controls collection of the Section object.
You can also create the module from Visual Basic by referring to the form's Module property while the form or report is in Design view , or by setting the HasModule property to True .
There are four ways to create the default instance of a form. You can open an existing form by using the user interface, by executing the OpenForm method of the DoCmd object, by calling the CreateForm method and switching the new form into Form view, or by using Visual Basic to create a variable of type Form to refer to the default instance. The following example opens an Employees form and points a Form object variable to it:
You can open an existing form by using the user interface, by executing the OpenForm method of the DoCmd object, by calling the CreateForm method and switching the new form into Form view, or by using Visual Basic to create a variable of type Form to refer to the default instance.
When you run this code, Microsoft Access opens the Employees form in Form view if it's not already open and sets the form's caption to New Employees. The form isn't visible until you explicitly set its Visible property to True . When the procedure that calls this code has finished executing, this instance of the form is destroyed; that is, the form is closed.
To work with the controls on a section of a form or report, use the Section property to return a reference to a Section object.
To carry out macro actions from code in Microsoft Access, use the DoCmd object and its methods. This object replaces the DoCmd statement that you used in versions 1. x and 2.0 of Microsoft Access to carry out a macro action.
To carry out macro actions from code in Microsoft Access, use the DoCmd object and its methods.
When you create a form or report in Microsoft Access 2002 or later, the form or report doesn't automatically have an associated module. When you click Code on the toolbar to view the form's or report's module, the module is created. You can also create the module from Visual Basic by referring to the form's Module property while the form or report is in Design view , or by setting the HasModule property to True .
Then refer to the Controls collection of the Section object.
The ControlType property constant for a Page control is acPage .
A Page object, in turn, has its own Controls collection, which contains all the controls on an individual page.
To determine whether an individual Module object represents a standard module or a class module, check the Module object's Type property.
Two types of Control objects, the tab control and option group control, have Controls collections that can contain multiple controls. The Controls collection belonging to the option group control contains any option button , check box , toggle button , or label controls in the option group.
Two types of Control objects, the tab control and option group control, have Controls collections that can contain multiple controls.
The Controls collection belonging to the option group control contains any option button , check box , toggle button , or label controls in the option group.
The tab control contains a Pages collection, which is a special type of Controls collection. The Pages collection contains Page objects. Page objects are also controls. The ControlType property constant for a Page control is acPage . A Page object, in turn, has its own Controls collection, which contains all the controls on an individual page.
Other Control objects have a Controls collection that can contain an attached label. These controls include the text box, option group, option button, toggle button, check box, combo box, list box, command button, bound object frame, and unbound object frame controls.
Other Control objects have a Controls collection that can contain an attached label.
These controls include the text box, option group, option button, toggle button, check box, combo box, list box, command button, bound object frame, and unbound object frame controls.
DataAccessPages Collection
The DataAccessPages collection contains all of the data access pages that are currently open in a Microsoft Access project (.adp) or Access database (.mdb).
Using the DataAccessPages Collection
Use the DataAccessPages collection in Visual Basic or in an expression to refer to data access pages that are currently open. For example, you can enumerate the DataAccessPages collection to set or return the values of properties of individual data access pages in the collection.
Use the DataAccessPages collection in Visual Basic or in an expression to refer to data access pages that are currently open.
For example, you can enumerate the DataAccessPages collection to set or return the values of properties of individual data access pages in the collection.
You can refer to an individual DataAccessPage object in the DataAccessPages collection either by referring to the data access page by name, or by referring to its index within the collection. If you want to refer to a specific data access page in the DataAccessPages collection, it's better to refer to the data access page by name because a data access page's collection index may change.
You can refer to an individual DataAccessPage object in the DataAccessPages collection either by referring to the data access page by name, or by referring to its index within the collection.
If you want to refer to a specific data access page in the DataAccessPages collection, it's better to refer to the data access page by name because a data access page's collection index may change.
The DataAccessPages collection is indexed beginning with zero. If you refer to a data access page by its index, the first data access page opened is DataAccessPages(0), the second form opened is DataAccessPages(1), and so on. If you opened Page1 and then opened Page2, Page2 would be referenced in the DataAccessPages collection by its index as DataAccessPages(1). If you then closed Page1, Page2 would be referenced in the DataAccessPages collection by its index as DataAccessPages(0).
The DataAccessPages collection is indexed beginning with zero.
If you refer to a data access page by its index, the first data access page opened is DataAccessPages(0), the second form opened is DataAccessPages(1), and so on.
If you opened Page1 and then opened Page2, Page2 would be referenced in the DataAccessPages collection by its index as DataAccessPages(1).
If you then closed Page1, Page2 would be referenced in the DataAccessPages collection by its index as DataAccessPages(0).
To list all data access pages in the database, whether open or closed, enumerate the AllDataAccessPages collection of the CurrentProject object. You can then use the Name property of each individual AccessObject object to return the name of a data access page.
To list all data access pages in the database, whether open or closed, enumerate the AllDataAccessPages collection of the CurrentProject object.
You can't add or delete a DataAccessPage object from the DataAccessPages collection.
The following example creates a new data access page and sets certain properties:
The next example enumerates the DataAccessPages collection and prints the name of each data access page in the DataAccessPages collection.
FormatConditions Collection
The FormatConditions collection represents the collection of conditional formats for a combo box or text box control. Each format is represented by a FormatCondition object.
Miscellaneous
Date/Time | Criteria Expressions | Windows API | Maintenance | more...
An index is a Microsoft Access feature that speeds up searching and sorting in a table. You can create an index for a field in the Indexes window of table Design view , or by setting the field's Indexed property to Yes.
You can create an index for a field in the Indexes window of table Design view , or by setting the field's Indexed property to Yes.
The FormatConditions collection represents the collection of conditional formats for a combo box or text box control.
Ribbon | Miscellaneous | more...
Each format is represented by a FormatCondition object.
For example, an import specification that imports data from a 1st_Excel12 workbook stores the name of the source Excel file, the name of the destination database, and other details, such as whether you appended to or created a new table, primary key information, field names, and so on.
Use the Add method of the ImportExportSpecifications collection to create a new ImportExportSpecification object.
Use the Execute method to run saved import or export operation.
The list in a list box consists of rows of data. Rows can have one or more columns, which can appear with or without headings.
MacroError Object
Represents the properties of a run-time error that occurs in a macro .
User Interface
Using the FormatConditions Collection
Use the FormatConditions property of a combo box or text box in Visual Basic or in an expression to return a FormatConditions collection. Use the Add method to create a new conditional format, and use the Modify method to change an existing conditional format.
Use the FormatConditions property of a combo box or text box in Visual Basic or in an expression to return a FormatConditions collection.
Use the Add method to create a new conditional format, and use the Modify method to change an existing conditional format.
Design | Controls | Printing | Events | more...
You can use the Modify method to change one of the formats, or the Delete method to delete a format.
Represents a saved import or export operation.
To embed or link a chart containing data from other applications, use an unbound object frame or bound object frame control.
Conditional formatting can also be set on a combo box or text box from the Conditional Formatting dialog box. The Conditional Formatting dialog box is available by clicking Conditional Formatting on the Format menu when a form is in Design view .
Forms Collection
The Forms collection contains all of the currently open forms in a Microsoft Access database .
Using the Forms Collection
Use the Forms collection in Visual Basic or in an expression to refer to forms that are currently open. For example, you can enumerate the Forms collection to set or return the values of properties of individual forms in the collection.
Use the Forms collection in Visual Basic or in an expression to refer to forms that are currently open.
For example, you can enumerate the Forms collection to set or return the values of properties of individual forms in the collection.
You can refer to an individual Form object in the Forms collection either by referring to the form by name, or by referring to its index within the collection. If you want to refer to a specific form in the Forms collection, it's better to refer to the form by name because a form's collection index may change.
You can refer to an individual Form object in the Forms collection either by referring to the form by name, or by referring to its index within the collection.
If you want to refer to a specific form in the Forms collection, it's better to refer to the form by name because a form's collection index may change.
You can also use the CreateControl method to add a Page object to the Pages collection of a tab control. To do this, you must specify the name of the tab control for the Parent argument of the CreateControl function. The ControlType property constant for a Page object is acPage .
If the form name includes a space, the name must be surrounded by brackets ([ ]).
Forms ! formname
Forms!OrderForm
Forms![ form name ]
The Forms collection is indexed beginning with zero. If you refer to a form by its index, the first form opened is Forms(0), the second form opened is Forms(1), and so on. If you opened Form1 and then opened Form2, Form2 would be referenced in the Forms collection by its index as Forms(1). If you then closed Form1, Form2 would be referenced in the Forms collection by its index as Forms(0).
The Forms collection is indexed beginning with zero.
If you refer to a form by its index, the first form opened is Forms(0), the second form opened is Forms(1), and so on.
If you opened Form1 and then opened Form2, Form2 would be referenced in the Forms collection by its index as Forms(1).
If you then closed Form1, Form2 would be referenced in the Forms collection by its index as Forms(0).
To list all forms in the database, whether open or closed, enumerate the AllForms collection of the CurrentProject object. You can then use the Name property of each individual AccessObject object to return the name of a form.
To list all forms in the database, whether open or closed, enumerate the AllForms collection of the CurrentProject object.
You can't add or delete a Form object from the Forms collection.
Modules Collection
The Modules collection contains all open standard modules and class modules in a Microsoft Access database.
Using the Modules Collection
All open modules are included in the Modules collection, whether they are uncompiled, are compiled, are in break mode, or contain the code that's running.
To determine whether an individual Module object represents a standard module or a class module, check the Module object's Type property.
The Modules collection belongs to the Microsoft Access Application object.
Individual Module objects in the Modules collection are indexed beginning with zero.
The following example illustrates how to use the Modules collection to loop through the open modules. The example prints the name if each open module in the Immediate window.
The following example illustrates how to use the Modules collection to loop through the open modules.
The example prints the name if each open module in the Immediate window.
Pages Collection
The Pages collection contains all Page objects in a tab control .
Using the Pages Collection
The Pages collection is a special kind of Controls collection belonging to the tab control. It contains Page objects, which are controls. The Pages collection differs from a typical Controls collection in that you can add and remove Page objects by using methods of the Pages collection.
To add a new Page object to the Pages collection from Visual Basic, use the Add method of the Pages collection. To remove an existing Page object, use the Remove method of the Pages collection. To count the number of Page objects in the Pages collection, use the Count property of the Pages collection.
Reports
To add a new Page object to the Pages collection from Visual Basic, use the Add method of the Pages collection.
To remove an existing Page object, use the Remove method of the Pages collection.
To count the number of Page objects in the Pages collection, use the Count property of the Pages collection.
You can also use the CreateControl method to add a Page object to the Pages collection of a tab control. To do this, you must specify the name of the tab control for the Parent argument of the CreateControl function. The ControlType property constant for a Page object is acPage .
You can also use the CreateControl method to add a Page object to the Pages collection of a tab control.
User Input | Controls | Design | Events | Printing | more...
To do this, you must specify the name of the tab control for the Parent argument of the CreateControl function.
The ControlType property constant for a Page object is acPage .
You can enumerate through the Pages collection by using the For Each...Next statement.
Individual Page objects in the Pages collection are indexed beginning with zero.
You can use the New keyword or the CreateObject method to create a new instance of a component. You can use the GetObject method to assign a variable to an existing instance of a component.
The Microsoft Access type library provides information about Microsoft Access objects to other components. You can set a reference to the Microsoft Access type library from a component and view its objects in the Object Browser.
You can set a reference to the Microsoft Access type library from a component and view its objects in the Object Browser.
To work with Microsoft Access objects through Automation, you must create an instance of the Microsoft Access Application object. For example, suppose you want to display data from Microsoft Excel in a Microsoft Access form or report. To launch Microsoft Access from Microsoft Excel, you can use the New keyword to create an instance of the Microsoft Access Application object. You can also use the CreateObject method to create a new instance of the Microsoft Access Application object, or you can use the GetObject method to point an object variable to an existing instance of Microsoft Access. Check your component's documentation to determine which syntax it supports.
Once you've launched an instance of Microsoft Access, if you want to control any Microsoft Access objects, you must open a database or project (.adp) in the Microsoft Access window by using either the OpenCurrentDatabase or the NewCurrentDatabase method for a database or by using the OpenAccessProject or the NewAccessProject method for a project.
If you've opened Microsoft Access only as a means of using the Data Access Objects provided by Microsoft DAO, then you don't need to open a database in the Microsoft Access window. You can use the DBEngine property of the Microsoft Access Application object to access objects in the Microsoft Office 12.0 Access Database Engine Object Library object library during an Automation operation.
You can use the DBEngine property of the Microsoft Access Application object to access objects in the Microsoft Office 12.0 Access Database Engine Object Library object library during an Automation operation.
Properties Collection
The Properties collection contains all of the built-in properties in an instance of an open form, report, or control. These properties uniquely characterize that instance of the object.
The Properties collection contains all of the built-in properties in an instance of an open form, report, or control.
These properties uniquely characterize that instance of the object.
Using the Properties Collection
Use the Properties collection in Visual Basic or in an expression to refer to form, report, or control properties on forms or reports that are currently open.
You can use the Properties collection of an object to enumerate the object's built-in properties. You don't need to know beforehand exactly which properties exist or what their characteristics ( Name and Value properties) are to manipulate them.
You can use the Properties collection of an object to enumerate the object's built-in properties.
You don't need to know beforehand exactly which properties exist or what their characteristics ( Name and Value properties) are to manipulate them.
In addition to the built-in properties, you can also create and add your own user-defined properties. To add a user-defined property to an existing instance of an object, see the AccessObjectProperties collection and Add method topics.
In addition to the built-in properties, you can also create and add your own user-defined properties.
To add a user-defined property to an existing instance of an object, see the AccessObjectProperties collection and Add method topics.
The following example enumerates the Forms collection and prints the name of each open form in the Forms collection. It then enumerates the Properties collection of each form and prints the name of each property and value.
References Collection
The References collection contains Reference objects representing each reference that's currently set.
Using the References Collection
The Reference objects in the References collection correspond to the list of references in the References dialog box, available by clicking References on the Tools menu. Each Reference object represents one selected reference in the list. References that appear in the References dialog box but haven't been selected aren't in the References collection.
The Reference objects in the References collection correspond to the list of references in the References dialog box, available by clicking References on the Tools menu.
Each Reference object represents one selected reference in the list.
References that appear in the References dialog box but haven't been selected aren't in the References collection.
You can enumerate through the References collection by using the For Each...Next statement.
The References collection belongs to the Microsoft Access Application object.
Individual Reference objects in the References collection are indexed beginning with 1.
Reports Collection
The Reports collection contains all of the currently open reports in a Microsoft Access database .
Using the Reports Collection
You can use the Reports collection in Visual Basic or in an expression to refer to reports that are currently open. For example, you can enumerate the Reports collection to set or return the values of properties of individual reports in the collection .
You can use the Reports collection in Visual Basic or in an expression to refer to reports that are currently open.
For example, you can enumerate the Reports collection to set or return the values of properties of individual reports in the collection .
You can refer to an individual Report object in the Reports collection either by referring to the report by name, or by referring to its index within the collection.
The Reports collection is indexed beginning with zero. If you refer to a report by its index, the first report is Reports(0), the second report is Reports(1), and so on. If you opened Report1 and then opened Report2, Report2 would be referenced in the Reports collection by its index as Reports(1). If you then closed Report1, Report2 would be referenced in the Reports collection by its index as Reports(0).
The Reports collection is indexed beginning with zero.
If you refer to a report by its index, the first report is Reports(0), the second report is Reports(1), and so on.
If you opened Report1 and then opened Report2, Report2 would be referenced in the Reports collection by its index as Reports(1).
If you then closed Report1, Report2 would be referenced in the Reports collection by its index as Reports(0).
To list all reports in the database, whether open or closed, enumerate the AllReports collection of the CurrentProject object. You can then use the Name property of each individual AccessObject object to return the name of a report.
To list all reports in the database, whether open or closed, enumerate the AllReports collection of the CurrentProject object.
In previous versions of Microsoft Access, you could use the CreateObject function or the GetObject function to point a variable to an instance of a component. In Microsoft Access 97 and above, you can also use the New keyword to create a new instance of some components.
In previous versions of Microsoft Access, you could use the CreateObject function or the GetObject function to point a variable to an instance of a component.
In Microsoft Access 97 and above, you can also use the New keyword to create a new instance of some components.
In Microsoft Access, you can set a reference to a component's type library to improve performance when you work with that component through Automation. Microsoft Access also includes the Object Browser , a tool that enables you to view objects in another component's type library, as well as their methods and properties.
In Microsoft Access, you can set a reference to a component's type library to improve performance when you work with that component through Automation.
Microsoft Access also includes the Object Browser , a tool that enables you to view objects in another component's type library, as well as their methods and properties.
In Microsoft Access 2002 or later, combo boxes accept Null values when the LimitToList property is set to True (1), whether or not the list contains Null values. In version 2.0, a combo box that has the LimitToList property set to True won't accept a Null value unless the list contains a Null value. If you want to prevent users from entering a Null value by using a combo box, set the Required property of the field in the table to Yes .
In Microsoft Access 2002 or later, combo boxes accept Null values when the LimitToList property is set to True (1), whether or not the list contains Null values.
If you want to prevent users from entering a Null value by using a combo box, set the Required property of the field in the table to Yes .
If you enter 3/3 in a field of type Date on a form or a table datasheet , the current year is automatically added in Microsoft Access 2002 or later. However, if you enter 3/3/ in the same field, Microsoft Access returns an error message. You must omit the last date delimiter so that Microsoft Access can translate the date into the proper format.
If you enter 3/3 in a field of type Date on a form or a table datasheet , the current year is automatically added in Microsoft Access 2002 or later.
In versions of Microsoft Access prior to 2002, Form and Report objects have associated class modules even if there's no code behind the object. In Microsoft Access 2002 or later, you can set a form's or report's HasModule property to False . When you set the HasModule property to False , the form or report will take up less disk space and will load faster because it will no longer have an associated class module.
In Microsoft Access 2002 or later, you can set a form's or report's HasModule property to False .
In versions 1. x and 2.0, you can use the Format property of a control to display different values for Null values and zero-length strings ( ). In Microsoft Access 2002 or later, to distinguish between Null values and zero-length strings in a control on a form, set the control's ControlSource property to an expression that tests for the Null value case. For example, to display Null or ZLS in a control, set its ControlSource property to the following expression:
In versions 1. x and 2.0, you can use the Format property of a control to display different values for Null values and zero-length strings ( ).
The Microsoft Access type library provides information about Microsoft Access objects to other components. You can set a reference to the Microsoft Access type library from a component and view its objects in the Object Browser.
The Microsoft Access type library provides information about Microsoft Access objects to other components.
If you use add-ins or library databases created in versions of Microsoft Access before 2002, you must convert them to Microsoft Access 2002 - 2003 format before you can use them with applications created in Access.
A Microsoft Access table can contain up to 32 indexes . Very complex tables that are a part of many relationships may exceed the index limit, and you won't be able to convert the database that contains these tables. The Microsoft Access database engine creates indexes on both sides of relationships between tables. If your database won't convert, delete some relationships and try again to convert the database.
The Microsoft Access database engine creates indexes on both sides of relationships between tables.
To work with Microsoft Access objects through Automation, you must create an instance of the Microsoft Access Application object. For example, suppose you want to display data from Microsoft Excel in a Microsoft Access form or report. To launch Microsoft Access from Microsoft Excel, you can use the New keyword to create an instance of the Microsoft Access Application object. You can also use the CreateObject function to create a new instance of the Microsoft Access Application object, or you can use the GetObject function to point an object variable to an existing instance of Microsoft Access. Check your component's documentation to determine which syntax it supports.
Once you've launched an instance of Microsoft Access, if you want to control any Microsoft Access objects, you must open a database (.mdb) or project (.adp) in the Microsoft Access window by using either the OpenCurrentDatabase or the NewCurrentDatabase method for a database or by using the OpenAccessProject or the NewAccessProject method for a project.
If you've opened Microsoft Access only as a means of using the Data Access Objects provided by Microsoft DAO, then you don't need to open a database in the Microsoft Access window. You can use the DBEngine property of the Microsoft Access Application object to access objects in the Microsoft DAO 3.6 object library during an Automation operation.
If you've opened Microsoft Access only as a means of using the Data Access Objects provided by Microsoft DAO, then you don't need to open a database in the Microsoft Access window.
You can use the DBEngine property of the Microsoft Access Application object to access objects in the Microsoft DAO 3.6 object library during an Automation operation.
Color Builder
The Color Builder is a Microsoft Access tool used to select colors from the palette or to create custom colors that you can save and use in forms and reports.
To run this builder, click the Build button next to the appropriate property in the property sheet.
Convert Library Databases and Add-Ins
You may also need to make some changes to the objects, macros, and procedures in your library databases and add-ins in order to make sure that they function properly.
Referencing and Loading Library Databases
Before using a library in Microsoft Access 2002 or later, you must establish a reference to the library database from each of your applications that uses it. You establish such a reference by clicking References on the Tools menu while in module Design view . A referenced database must be in Microsoft Access 2002 format.
Before using a library in Microsoft Access 2002 or later, you must establish a reference to the library database from each of your applications that uses it.
You establish such a reference by clicking References on the Tools menu while in module Design view .
A referenced database must be in Microsoft Access 2002 format.
A library database should contain only Visual Basic code, which you can call from any application that maintains a reference to that library. In versions 1. x and 2.0 of Microsoft Access, you load a library database at startup by creating an entry in the Libraries section of your .ini file. Most of the information that's stored in an .ini file in versions 1. x and 2.0 is stored in the Windows registry in later versions. However, there's no need to create a Windows registry key in order to use a library database.
A library database should contain only Visual Basic code, which you can call from any application that maintains a reference to that library.
In versions 1. x and 2.0 of Microsoft Access, you load a library database at startup by creating an entry in the Libraries section of your .ini file.
Most of the information that's stored in an .ini file in versions 1. x and 2.0 is stored in the Windows registry in later versions.
However, there's no need to create a Windows registry key in order to use a library database.
Circular References Between Libraries
In versions 1. x and 2.0 of Microsoft Access, you can make circular library references. However, these aren't allowed in later versions of Microsoft Access. In other words, once you've created a reference from Library A to Library B, you cannot create a reference from Library B to Library A.
In versions 1. x and 2.0 of Microsoft Access, you can make circular library references.
However, these aren't allowed in later versions of Microsoft Access.
In other words, once you've created a reference from Library A to Library B, you cannot create a reference from Library B to Library A.
Custom Add-ins Menu Behavior
In versions 1. x and 2.0 of Microsoft Access, add-ins automatically appear on the Add-Ins submenu of the File menu. In later versions of Microsoft Access, the Add-Ins submenu is on the Tools menu. In Microsoft Access 2002 or later you can also reference add-ins from any toolbar or menu.
Convert Microsoft Access Tables, Forms, and Reports
Several changes introduced by Microsoft Access 2002 might affect the behavior of your version 1. x or 2.0 applications. The following sections provide more information about those changes.
Several changes introduced by Microsoft Access 2002 might affect the behavior of your version 1. x or 2.0 applications.
The following sections provide more information about those changes.
Indexes and Relationships
A Microsoft Access table can contain up to 32 indexes . Very complex tables that are a part of many relationships may exceed the index limit, and you won't be able to convert the database that contains these tables. Version 3.6 of the Microsoft Jet database engine creates indexes on both sides of relationships between tables. If your database won't convert, delete some relationships and try again to convert the database.
A Microsoft Access table can contain up to 32 indexes .
Very complex tables that are a part of many relationships may exceed the index limit, and you won't be able to convert the database that contains these tables.
Version 3.6 of the Microsoft Jet database engine creates indexes on both sides of relationships between tables.
If your database won't convert, delete some relationships and try again to convert the database.
The LimitToList Property of Combo Boxes
In Microsoft Access 2002 or later, combo boxes accept Null values when the LimitToList property is set to True (1), whether or not the list contains Null values. In version 2.0, a combo box that has the LimitToList property set to True won't accept a Null value unless the list contains a Null value. If you want to prevent users from entering a Null value by using a combo box, set the Required property of the field in the table to Yes .
In Microsoft Access 2002 or later, combo boxes accept Null values when the LimitToList property is set to True (1), whether or not the list contains Null values.
In version 2.0, a combo box that has the LimitToList property set to True won't accept a Null value unless the list contains a Null value.
If you want to prevent users from entering a Null value by using a combo box, set the Required property of the field in the table to Yes .
Menus and In-Place Activation of OLE Objects
In order to make additional functionality available to you while activating OLE objects in place, some menu commands may have been moved to a menu that isn't replaced when you activate an OLE server .
The links provide pointers to important, procedure-based Help topics.
Data Access
Structured Query Language (SQL) | Data Access Objects (DAO) | ActiveX Data Objects (ADO) | XML | more...
Macros in your converted application that use a DoMenuItem action to carry out a version 2.0 menu command when a component is activated won't be affected by the changes. Version 2.0 commands are mapped to their equivalents in later versions of Microsoft Access.
Macros in your converted application that use a DoMenuItem action to carry out a version 2.0 menu command when a component is activated won't be affected by the changes.
Version 2.0 commands are mapped to their equivalents in later versions of Microsoft Access.
Referencing a Control on a Read-Only Form
In Microsoft Access 2002 or later, you can't use an expression to refer to the value of a control on a read-only form that's bound to an empty record source. In previous versions, the expression returns a Null value. Before you reference a control on a read-only form, you should make sure that the form's record source contains records.
In Microsoft Access 2002 or later, you can't use an expression to refer to the value of a control on a read-only form that's bound to an empty record source.
The essential categories for what you can do with Access are listed in this topic.
In previous versions, the expression returns a Null value.
Before you reference a control on a read-only form, you should make sure that the form's record source contains records.
Date Fields and Data Entry
If you enter 3/3 in a field of type Date on a form or a table datasheet , the current year is automatically added in Microsoft Access 2002 or later. However, if you enter 3/3/ in the same field, Microsoft Access returns an error message. You must omit the last date delimiter so that Microsoft Access can translate the date into the proper format.
If you enter 3/3 in a field of type Date on a form or a table datasheet , the current year is automatically added in Microsoft Access 2002 or later.
However, if you enter 3/3/ in the same field, Microsoft Access returns an error message.
You must omit the last date delimiter so that Microsoft Access can translate the date into the proper format.
Buttons Created with the Command Button Wizard
If you used the Command Button Wizard in version 2.0 or 7.0 of Microsoft Access to generate code that called another application, you should delete the button and re-create it by using the Command Button Wizard in Microsoft Access 2002 or later.
Form and Report Class Modules
In versions of Microsoft Access prior to 2002, Form and Report objects have associated class modules even if there's no code behind the object. In Microsoft Access 2002 or later, you can set a form's or report's HasModule property to False . When you set the HasModule property to False , the form or report will take up less disk space and will load faster because it will no longer have an associated class module.
In versions of Microsoft Access prior to 2002, Form and Report objects have associated class modules even if there's no code behind the object.
In Microsoft Access 2002 or later, to distinguish between Null values and zero-length strings in a control on a form, set the control's ControlSource property to an expression that tests for the Null value case.
How Do I... in Access
This topic links to programming tasks (how-to and walkthrough topics) for common Access scenarios.
How Do I ... is your gateway to key task-based topics about programming and application development using Microsoft Office Access 2007. The essential categories for what you can do with Access are listed in this topic. The links provide pointers to important, procedure-based Help topics.
How Do I ... is your gateway to key task-based topics about programming and application development using Microsoft Office Access 2007.
In Microsoft Access 2002 or later, you can set a form's or report's HasModule property to False .
When you set the HasModule property to False , the form or report will take up less disk space and will load faster because it will no longer have an associated class module.
Converted Version 2.0 Report Has Different Margins
You may encounter problems when trying to print or preview a report in Microsoft Access 2002 or later that has been converted from Microsoft Access 2.0 if the report has some margins set to 0. When you convert a Microsoft Access 2.0 report, margins aren't set to 0; they are instead set to the minimum margin that's valid for the default printer. This prevents the report from printing data in the unprintable region of the printer.
You may encounter problems when trying to print or preview a report in Microsoft Access 2002 or later that has been converted from Microsoft Access 2.0 if the report has some margins set to 0.
When you convert a Microsoft Access 2.0 report, margins aren't set to 0; they are instead set to the minimum margin that's valid for the default printer.
This prevents the report from printing data in the unprintable region of the printer.
To resolve this problem, reduce the column width, column spacing, or number of columns in the report so that the width of the columns plus the width of the default margins is equal to or less than the width of your paper.
Can't Use the Format Property to Distinguish Null Values and Zero-Length Strings
In versions 1. x and 2.0, you can use the Format property of a control to display different values for Null values and zero-length strings ( ). In Microsoft Access 2002 or later, to distinguish between Null values and zero-length strings in a control on a form, set the control's ControlSource property to an expression that tests for the Null value case. For example, to display Null or ZLS in a control, set its ControlSource property to the following expression:
In versions 1. x and 2.0, you can use the Format property of a control to display different values for Null values and zero-length strings ( ).
In Microsoft Access 2002 or later, to distinguish between Null values and zero-length strings in a control on a form, set the control's ControlSource property to an expression that tests for the Null value case.
For example, to display Null or ZLS in a control, set its ControlSource property to the following expression:
=IIf(IsNull([MyControl]), Null, Format([MyControl], @;ZLS))
Custom Methods and Properties
You can use a class module to create a definition for a new custom object. When you create a new instance of a class , you create a new object and return a reference to it.
You can use a class module to create a definition for a new custom object.
When you create a new instance of a class , you create a new object and return a reference to it.
Any public procedures defined within the class module become methods of the new object. The Sub statement defines a method that doesn't return a value; the Function statement defines a method that may return a value of a specified type.
Any public procedures defined within the class module become methods of the new object.
The Sub statement defines a method that doesn't return a value; the Function statement defines a method that may return a value of a specified type.
Any Property Let , Property Get or Property Set procedures you define become properties of the new object. Property Get procedures retrieve the value of a property. Property Let procedures set the value of a nonobject property. Property Set procedures set the value of an object property.
Any Property Let , Property Get or Property Set procedures you define become properties of the new object.
Property Get procedures retrieve the value of a property.
Property Let procedures set the value of a nonobject property.
Property Set procedures set the value of an object property.
For example, you can use a class module to create an interface layer between your application and a set of Windows application programming interface (API ) functions that it calls. To do this, you create a set of simple procedures that call more complicated procedures in a DLL . When you create an instance of this class, the procedures you've created become methods of the new object. You can apply these methods as you would the methods of any object, and in doing so you also call the API functions.
For example, you can use a class module to create an interface layer between your application and a set of Windows application programming interface (API ) functions that it calls.
To do this, you create a set of simple procedures that call more complicated procedures in a DLL .
When you create an instance of this class, the procedures you've created become methods of the new object.
You can apply these methods as you would the methods of any object, and in doing so you also call the API functions.
Form Section
A form section is part of a form such as a header, footer, or detail section.
You can set section properties which are attributes of a form that affect the appearance or behavior of that section. For example, you can set the CanGrow property to specify whether the section will increase vertically to print all the data the section contains. Section properties are set in form Design view .
SmartTagActions Collection
Represents a collection of actions for an individual smart tag or a type of smart tag.
Smart tag actions are processes that are programmed into smart tags; they allow users to perform certain functions related to the smart tag. For example, one action for a smart tag might be to access a Web site, while another action inserts contact information from Microsoft Outlook, while yet another action displays a map and driving directions.
You can set section properties which are attributes of a form that affect the appearance or behavior of that section.
For example, you can set the CanGrow property to specify whether the section will increase vertically to print all the data the section contains.
Using the Byte Data Type (Differences in String Function Operations)
Smart tag actions are processes that are programmed into smart tags; they allow users to perform certain functions related to the smart tag.
Using the SmartTagActions Collection
Section properties are set in form Design view .
Form
A form is a Microsoft Access database object on which you place controls for taking actions or for entering, displaying, and editing data in fields.
Hidden Properties
The following table lists properties that have been hidden in the Visual Basic object model in Microsoft Access 2002 and later because their functionality has been replaced by new language elements. These properties are supported only for backward compatibility; for new code, use the replacement functionality provided in Microsoft Access 2002 or later. To view hidden objects in the Object Browser, right-click in the Object Browser window and click Show Hidden Members on the shortcut menu.
Object
Hidden Property
Replacement
None
Index
An index is a Microsoft Access feature that speeds up searching and sorting in a table. You can create an index for a field in the Indexes window of table Design view , or by setting the field's Indexed property to Yes.
An index is a Microsoft Access feature that speeds up searching and sorting in a table.
You can create an index for a field in the Indexes window of table Design view , or by setting the field's Indexed property to Yes.
The primary key of a table is automatically indexed, and fields for which the data type is Memo or OLE Object can't be indexed.
Language-Specific Properties and Methods
Properties and methods that are available only in Asian or right-to-left languages are listed in the following table.
Property or Method
Macro Actions and Methods of the DoCmd Object
To carry out macro actions from code in Microsoft Access, use the DoCmd object and its methods. This object replaces the DoCmd statement that you used in versions 1. x and 2.0 of Microsoft Access to carry out a macro action.
To carry out macro actions from code in Microsoft Access, use the DoCmd object and its methods.
This object replaces the DoCmd statement that you used in versions 1. x and 2.0 of Microsoft Access to carry out a macro action.
When you convert a database, Microsoft Access automatically converts any DoCmd statements and the actions that they carried out in your Access Basic code to methods of the DoCmd object by replacing the space with the . (dot) operator.
Some macro actions work differently in Microsoft Access 9.0 and later than in version 1. x , 2.0, or 7.0; these differences are detailed below.
Databases Created with Microsoft Access 95
The DoMenuItem Action
The DoMenuItem action is no longer used in Microsoft Access. The RunCommand action can be used to accomplish the tasks for which you used to use the DoMenuItem action.
The DoMenuItem action is no longer used in Microsoft Access.
The RunCommand action can be used to accomplish the tasks for which you used to use the DoMenuItem action.
When you enable a database created with a prior version of Microsoft Access, the DoMenuItem action will continue to work as it did before.
When you convert a database created with a prior version of Microsoft Access, all DoMenuItem actions in macros are replaced with RunCommand actions the first time that the macros are saved after conversion. DoMenuItem methods used in Visual Basic procedures aren't changed.
When you convert a database created with a prior version of Microsoft Access, all DoMenuItem actions in macros are replaced with RunCommand actions the first time that the macros are saved after conversion.
DoMenuItem methods used in Visual Basic procedures aren't changed.
Databases Created with Microsoft Access Version 1. x or 2.0
The TransferSpreadsheet Action
Microsoft Access can't import Microsoft Excel version 2.0 spreadsheets or Lotus 1-2-3 version 1.0 spreadsheets. If your converted database contains a macro that provided this functionality by using the TransferSpreadsheet action in Microsoft Access version 1. x or 2.0, converting the database will change the Spreadsheet Type argument to Microsoft Excel version 3.0 (if you originally specified Microsoft Excel version 2.0), or causes an error if you originally specified Lotus 1-2-3 version 1.0 format.
Microsoft Access can't import Microsoft Excel version 2.0 spreadsheets or Lotus 1-2-3 version 1.0 spreadsheets.
If your converted database contains a macro that provided this functionality by using the TransferSpreadsheet action in Microsoft Access version 1. x or 2.0, converting the database will change the Spreadsheet Type argument to Microsoft Excel version 3.0 (if you originally specified Microsoft Excel version 2.0), or causes an error if you originally specified Lotus 1-2-3 version 1.0 format.
To work around this problem, convert the spreadsheets to a later version of Microsoft Excel or Lotus 1-2-3 before importing them into Microsoft Access.
The TransferText and TransferSpreadsheet Actions
In Microsoft Access, you can't use a SQL statement to specify data to export when you're using the TransferText action or the TransferSpreadsheet action. Instead of using a SQL statement, you must first create a query and then specify the name of the query in the Table Name argument.
In Microsoft Access, you can't use a SQL statement to specify data to export when you're using the TransferText action or the TransferSpreadsheet action.
Instead of using a SQL statement, you must first create a query and then specify the name of the query in the Table Name argument.
Comparisons Involving Null Values
In Microsoft Access versions 1.x and 2.0, if you compare two expressions within a macro condition by using a comparison operator and one of the expressions is Null , Access Basic will return True or False for the comparison, depending on which comparison operator you use. In Microsoft Access 2000 and later, Visual Basic returns Null for a comparison in which one expression is Null . To determine whether the comparison evaluates to Null , use the IsNull function to check the result of the comparison.
In Microsoft Access versions 1.x and 2.0, if you compare two expressions within a macro condition by using a comparison operator and one of the expressions is Null , Access Basic will return True or False for the comparison, depending on which comparison operator you use.
In Microsoft Access 2000 and later, Visual Basic returns Null for a comparison in which one expression is Null .
To determine whether the comparison evaluates to Null , use the IsNull function to check the result of the comparison.
Improvements in Compilation Performance
Microsoft Access includes improvements to module loading and compilation performance to make your code compile and run faster.
Form and Report Modules Created on Demand
When you create a form or report in Microsoft Access 2002 or later, the form or report doesn't automatically have an associated module. When you click Code on the toolbar to view the form's or report's module, the module is created. You can also create the module from Visual Basic by referring to the form's Module property while the form or report is in Design view , or by setting the HasModule property to True .
When you create a form or report in Microsoft Access 2002 or later, the form or report doesn't automatically have an associated module.
When you click Code on the toolbar to view the form's or report's module, the module is created.
The setting of the HasModule property indicates whether a form or report currently has an associated module.
Chr Function and ChrB Function (Differences in String Function Operations)
Input and InputB Functions (Differences in String Function Operations)
Since a form or report module isn't created until you need to add code to it, your project may have fewer modules to compile, resulting in improved compilation performance. Also, forms and reports without modules load more quickly than those with modules.
Since a form or report module isn't created until you need to add code to it, your project may have fewer modules to compile, resulting in improved compilation performance.
Also, forms and reports without modules load more quickly than those with modules.
Compiling on Demand
It's a good idea to explicitly compile the modules in your project by using the commands described above, but it's not necessary. Microsoft Access compiles a module before running a procedure in it if the module hasn't already been compiled.
It's a good idea to explicitly compile the modules in your project by using the commands described above, but it's not necessary.
Microsoft Access compiles a module before running a procedure in it if the module hasn't already been compiled.
When a module is loaded for execution, Microsoft Access checks to see whether the module has already been compiled. If not, Microsoft Access compiles the module immediately prior to executing a procedure within it. The process of compiling slows down your code, so code in modules that have been saved in a compiled state will run faster.
Note that in Microsoft Access 95, when you run a procedure in one module, all modules in the potential call tree are loaded, although by default they aren't compiled until a procedure within them is called. Because Microsoft Access 97 (and later versions) load modules on a need-only basis, your code may run faster in many cases.
Note that in Microsoft Access 95, when you run a procedure in one module, all modules in the potential call tree are loaded, although by default they aren't compiled until a procedure within them is called.
For constant names that have changed, the old constants will still work. For example, one of the intrinsic constants for the save argument of the Close method of the DoCmd object was acPrompt . It's now acSavePrompt , but acPrompt will still work.
For example, one of the intrinsic constants for the save argument of the Close method of the DoCmd object was acPrompt .
Because Microsoft Access 97 (and later versions) load modules on a need-only basis, your code may run faster in many cases.
You can further enhance performance by grouping procedures in modules to reduce unnecessary compilations. Group procedures in modules with other procedures that they call, as opposed to grouping them in modules with unrelated procedures.
You can further enhance performance by grouping procedures in modules to reduce unnecessary compilations.
Group procedures in modules with other procedures that they call, as opposed to grouping them in modules with unrelated procedures.
Style for Intrinsic Constants
In Microsoft Access, all intrinsic constants are contained in type libraries and are visible in the Object Browser . Microsoft Access includes type libraries for Microsoft Access, ActiveX Data Objects (ADO), Data Access Objects (DAO), and Visual Basic. Each of these type libraries includes intrinsic constants.
In Microsoft Access, all intrinsic constants are contained in type libraries and are visible in the Object Browser .
Microsoft Access includes type libraries for Microsoft Access, ActiveX Data Objects (ADO), Data Access Objects (DAO), and Visual Basic.
Each of these type libraries includes intrinsic constants.
Additionally, intrinsic constants in Microsoft Access are a mix of lowercase and uppercase, and parts of the constant are concatenated rather than separated by underscores. For example, the constant A_NORMAL in versions 1. x and 2.0 is now acNormal .
Additionally, intrinsic constants in Microsoft Access are a mix of lowercase and uppercase, and parts of the constant are concatenated rather than separated by underscores.
For example, the constant A_NORMAL in versions 1. x and 2.0 is now acNormal .
Intrinsic constants in databases created with previous versions of Microsoft Access won't automatically be converted to the new constant format, but old constants will continue to work without errors. However, it's recommended that you use the new format when writing new code.
Intrinsic constants in databases created with previous versions of Microsoft Access won't automatically be converted to the new constant format, but old constants will continue to work without errors.
However, it's recommended that you use the new format when writing new code.
Create Partial Replicas
What Are Partial Replicas?
Partial replicas are replicas that contain only a subset of records in a full replica. To create a partial replica, you specify a filter that restricts the data that's synchronized to a subset of the full database. By using partial replicas, you can synchronize a replica with only the data that you need, rather than with an entire database.
Partial replicas are replicas that contain only a subset of records in a full replica.
To create a partial replica, you specify a filter that restricts the data that's synchronized to a subset of the full database.
By using partial replicas, you can synchronize a replica with only the data that you need, rather than with an entire database.
For example, a business might store its entire sales database at the headquarters office but replicate only regional data to its regional offices across the country/region. You can create a separate replica for each regional office that contains only the data relating to that region. The database at the headquarters office would be a full replica, with which each partial replica would be synchronized.
For example, a business might store its entire sales database at the headquarters office but replicate only regional data to its regional offices across the country/region.
You can create a separate replica for each regional office that contains only the data relating to that region.
The database at the headquarters office would be a full replica, with which each partial replica would be synchronized.
Advantages of Using Partial Replicas
Partial replicas can make your database effectively smaller, since you need only replicate the portions that you work with frequently. Synchronizing a partial replica takes less time, and the replica itself requires less disk space.
Partial replicas can make your database effectively smaller, since you need only replicate the portions that you work with frequently.
Synchronizing a partial replica takes less time, and the replica itself requires less disk space.
Partial replicas can help restrict access to data. In the case of a sales database, partial replicas can help ensure that people in a regional sales office won't view sales data for other regional offices. Although you can use partial replicas to restrict access to records, they aren't a substitute for a security system.
Partial replicas can help restrict access to data.
In the case of a sales database, partial replicas can help ensure that people in a regional sales office won't view sales data for other regional offices.
Although you can use partial replicas to restrict access to records, they aren't a substitute for a security system.
Partial replicas also have benefits for replicating data over local area networks (LANs) and wide area networks (WANs). By restricting which data is replicated, partial replicas can reduce the amount of data transferred over a LAN or a long-distance carrier. This can reduce network traffic and lower telecommunications costs.
Partial replicas also have benefits for replicating data over local area networks (LANs) and wide area networks (WANs).
By restricting which data is replicated, partial replicas can reduce the amount of data transferred over a LAN or a long-distance carrier.
This can reduce network traffic and lower telecommunications costs.
Creating a Partial Replica with ActiveX Data Objects (ADO) Using the Jet & Replication Objects 2.5 Library (msjro.dll)
To create a partial replica, follow these steps:
Use the CreateReplica method on a Replica object, specifying the jrRepTypePartial constant in the replicatype argument. This creates the partial replica.
Use the CreateReplica method on a Replica object, specifying the jrRepTypePartial constant in the replicatype argument.
This creates the partial replica.
Use the Filters property to set the desired filters and relationships that determine which data to replicate from the full replica.
Use the PopulatePartial method to transfer all records from the full replica that meet the new replica filter criteria.
When you change data or the filter criteria in the partial replica, you should use the Synchronize and PopulatePartial methods together to ensure that all data is propagated to the full replica and that the partial replica is repopulated based on the current filter criteria.
Once you create a partial replica, you can't convert it to a full replica. If you remove all of the replica filters and replica relations within the partial replica, it will contain all the records of a full replica, but it will still have the same limitations and restrictions of a partial replica.
Once you create a partial replica, you can't convert it to a full replica.
If you remove all of the replica filters and replica relations within the partial replica, it will contain all the records of a full replica, but it will still have the same limitations and restrictions of a partial replica.
Creating a Partial Replica with Data Access Objects (DAO)
Use the MakeReplica method on a Database object, specifying the dbRepMakePartial constant in the options argument. This creates the partial replica.
Use the MakeReplica method on a Database object, specifying the dbRepMakePartial constant in the options argument.
Use the ReplicaFilter and PartialReplica properties to set the desired filters and relationships that determine which data to replicate from the full replica.
Partial Replicas and Referential Integrity
In a replica that has relationships that enforce referential integrity, many of the tables in the database may be related to the table on which your filter is based. When you create a partial replica, you need to make certain that you include any tables that are related to the table containing the data you want.
In a replica that has relationships that enforce referential integrity, many of the tables in the database may be related to the table on which your filter is based.
When you create a partial replica, you need to make certain that you include any tables that are related to the table containing the data you want.
For example, if you're using the Northwind sample database, you might place a filter on an Employees table, such as [EmployeeID]=1, that synchronizes only one employee's records. Because the Employees table is in a relationship with the Orders and Order Details tables, you must also include those tables so that your partial replica includes the corresponding records for that employee in the Orders and Order Details tables.
For example, if you're using the Northwind sample database, you might place a filter on an Employees table, such as [EmployeeID]=1, that synchronizes only one employee's records.
Because the Employees table is in a relationship with the Orders and Order Details tables, you must also include those tables so that your partial replica includes the corresponding records for that employee in the Orders and Order Details tables.
You may need to include other tables that are only indirectly related to your filter. For example, you may want your partial replica to include a list of all products so that new orders can include any products that are available. In this case, you must include the Products table in your partial replica.
You may need to include other tables that are only indirectly related to your filter.
For example, you may want your partial replica to include a list of all products so that new orders can include any products that are available.
In this case, you must include the Products table in your partial replica.
You should also be aware of tables in your database that have no enforced relationships, such as lookup tables, or tables with relationships where referential integrity isn't enforced. For example, a table that populates a combo box might not take part in any relationships. If you choose to include such a table, all records will be retrieved; otherwise no records will be retrieved.
Program with Class Modules
In Microsoft Access, there were two types of modules: standard modules and class modules . In Microsoft Access 95, class modules existed only in association with a form or report. In Microsoft Access 97, they also existed on the Modules tab of the Database window .
To return the SmartTagProperties collection for a smart tag, use the Properties property of the SmartTag object.
Unlike the SmartTags collections in Microsoft Excel and Microsoft Word, the SmartTags collection in Microsoft Access is zero-based. Therefore, the code control.SmartTags(0) returns the first smart tag for the specified control.
Unlike the SmartTags collections in Microsoft Excel and Microsoft Word, the SmartTags collection in Microsoft Access is zero-based.
Therefore, the code control.SmartTags(0) returns the first smart tag for the specified control.
Represents a smart tag that has been added to a control on a form or report. The SmartTag object is a member of the SmartTags collection.
Represents a smart tag that has been added to a control on a form or report.
Unlike the SmartTags collections in Microsoft Excel and Microsoft Word, the SmartTags collection in Microsoft Access is zero-based. Therefore, the code control.SmartTags(0) r eturns the first smart tag for the specified control.
Therefore, the code control.SmartTags(0) r eturns the first smart tag for the specified control.
In Microsoft Access, there were two types of modules: standard modules and class modules .
In Microsoft Access 95, class modules existed only in association with a form or report.
In Microsoft Access 97, they also existed on the Modules tab of the Database window .
Creating Custom Objects with Class Modules
You can use a class module to create a definition for a custom object. The name with which you save the class module becomes the name of your custom object. Public Sub and Function procedures that you define within a class module become custom methods of the object. Public Property Let , Property Get , and Property Set procedures become properties of the object.
You can use a class module to create a definition for a custom object.
The name with which you save the class module becomes the name of your custom object.
Public Sub and Function procedures that you define within a class module become custom methods of the object.
Public Property Let , Property Get , and Property Set procedures become properties of the object.
Once you've defined procedures within the class module, you can create the new object by creating a new instance of the class. To create a new instance of a class, you declare a variable of the type defined by that class. For example, if the name of your class is ABasicClass, you would create a new instance of it in the following manner:
Once you've defined procedures within the class module, you can create the new object by creating a new instance of the class.
To create a new instance of a class, you declare a variable of the type defined by that class.
For example, if the name of your class is ABasicClass, you would create a new instance of it in the following manner:
When you run the code containing this declaration, Visual Basic creates the new instance. You can then apply its methods and properties by using the variable abc . For example, if you've defined a custom method called ListNames, you could apply it as follows:
When you run the code containing this declaration, Visual Basic creates the new instance.
You can then apply its methods and properties by using the variable abc .
For example, if you've defined a custom method called ListNames, you could apply it as follows:
New in Microsoft Access 95: Creating the Default Instance of a Form Class
When you open a form in Form view , whether from the user interface or from Visual Basic, you create an instance of that form's class module. In other words, you designate space in memory where the object now exists, and you can then call its methods and set or return its properties from code, as you would for any built-in object. The same is true when you open a report in Print Preview .
When you open a form in Form view , whether from the user interface or from Visual Basic, you create an instance of that form's class module.
The form isn't visible until you explicitly set its Visible property to True .
In other words, you designate space in memory where the object now exists, and you can then call its methods and set or return its properties from code, as you would for any built-in object.
The same is true when you open a report in Print Preview .
When you refer to a form in Visual Basic code, you're usually working with the default instance of the form's class. A form's class has only one default instance. You can also create multiple instances of the same form's class from Visual Basic. When you create multiple instances of a form's class, you create nondefault instances.
When you refer to a form in Visual Basic code, you're usually working with the default instance of the form's class.
A form's class has only one default instance.
You can also create multiple instances of the same form's class from Visual Basic.
When you create multiple instances of a form's class, you create nondefault instances.
There are four ways to create the default instance of a form. You can open an existing form by using the user interface, by executing the OpenForm method of the DoCmd object, by calling the CreateForm method and switching the new form into Form view, or by using Visual Basic to create a variable of type Form to refer to the default instance. The following example opens an Employees form and points a Form object variable to it:
There are four ways to create the default instance of a form.
You can open an existing form by using the user interface, by executing the OpenForm method of the DoCmd object, by calling the CreateForm method and switching the new form into Form view, or by using Visual Basic to create a variable of type Form to refer to the default instance.
The following example opens an Employees form and points a Form object variable to it:
Microsoft Access also provides a shortcut that enables you to open a form and refer to a method or property of that form or one of its controls in one step. You refer to the form's class module as shown in the following example:
Microsoft Access also provides a shortcut that enables you to open a form and refer to a method or property of that form or one of its controls in one step.
You refer to the form's class module as shown in the following example:
When you run this code, Microsoft Access opens the Employees form in Form view if it's not already open and sets the form's caption to New Employees. The form isn't visible until you explicitly set its Visible property to True . When the procedure that calls this code has finished executing, this instance of the form is destroyed; that is, the form is closed.
When you run this code, Microsoft Access opens the Employees form in Form view if it's not already open and sets the form's caption to New Employees.
A nondefault instance of a form's class can't be referred to by name in the Forms collection. You can refer to it by index number only. Since you can create multiple nondefault instances of a form, and each instance has the same name, you can have more than one form with the same name in the Forms collection, without any means of distinguishing them other than by index number.
When the procedure that calls this code has finished executing, this instance of the form is destroyed; that is, the form is closed.
Input and InputB Functions
Processing ANSI String Bytes
Sample Functions that perform operations that are compatible with byte processing functions of 16-bit versions
Using the Byte Data Type
Asc Function and AscB Function (Differences in String Function Operations)
The memory storage formats for text differ between Visual Basic for Applications (VBA) code and Access Basic code. (Access Basic was used in early versions of Microsoft Access.) Text is stored in ANSI format within Access Basic code and in Unicode format in Visual Basic. This topic discusses one potential issue when handling strings in the current version of Microsoft Access. For more information, see Differences in String Function Operations .
If you try to run this code when the Employees form is open in Design view , Microsoft Access generates a run-time error . The form must either be open in Form view or not open at all.
Calling the Windows API
If you try to run this code when the Employees form is open in Design view , Microsoft Access generates a run-time error .
The form must either be open in Form view or not open at all.
If you use this syntax to change a property of the form or one of its controls, that change is lost when the instance of the form is destroyed. This holds true any time you change a property setting for a form in Form view. You must change the property in Design view and save the change with the form.
If you use this syntax to change a property of the form or one of its controls, that change is lost when the instance of the form is destroyed.
This holds true any time you change a property setting for a form in Form view.
You must change the property in Design view and save the change with the form.
Creating Multiple Nondefault Instances of Forms
You can create multiple nondefault instances of a form's class if you want to display more than one instance of a form at a time. For example, you might want to display the records for an employee and the employee's manager at the same time. You can create one instance of the Employees form's class to display the employee's record, and one to display the manager's record.
You can create multiple nondefault instances of a form's class if you want to display more than one instance of a form at a time.
For example, you might want to display the records for an employee and the employee's manager at the same time.
You can create one instance of the Employees form's class to display the employee's record, and one to display the manager's record.
To create new, nondefault instances of a form's class from Visual Basic, declare a variable for which the type is the name of the form class module. You must include the New keyword in the variable declaration. For example, the following code creates a new instance of the Employees form and assigns it to a variable of type Form :
To create new, nondefault instances of a form's class from Visual Basic, declare a variable for which the type is the name of the form class module.
You must include the New keyword in the variable declaration.
For example, the following code creates a new instance of the Employees form and assigns it to a variable of type Form :
This nondefault instance of the form isn't visible until you explicitly set its Visible property.
When the procedure that creates this instance has finished executing, the instance is removed from memory unless you've declared the variable representing it as a module-level variable . Since module-level variables retain their values until they are reset with the Reset command on the Run menu or the Reset button on the toolbar, the form will stay open if the variable has been declared as a module-level variable.
The condition is met if the Visible property setting for the Employees form equals True .
You can use the constant Null anywhere in Microsoft Access. For example, you can use Null to set the DefaultValue property for a form control by using the following expression:
When the procedure that creates this instance has finished executing, the instance is removed from memory unless you've declared the variable representing it as a module-level variable .
A query field represents data from a table linked to the query. By default, a query field inherits all the properties that it has in the underlying table or query. For example, if a table design specifies the display format of the Order Date field as Medium Date in the field's Format property, the Order Date field is formatted in the query recordset as Medium Date. Because the underlying field properties are the defaults, they aren't displayed on the property sheet.
For example, if a table design specifies the display format of the Order Date field as Medium Date in the field's Format property, the Order Date field is formatted in the query recordset as Medium Date.
If you call a procedure from a form, and that procedure has the same name as a control on the form, you must fully qualify the procedure call with the name of the module in which it resides. For example, if you want to call a procedure named PrintInvoice that resides in a standard module named Utilities, and there's also a button on the same form named PrintInvoice, use the fully qualified name Utilities.PrintInvoice when you call the procedure from your form or form module .
For example, if you want to call a procedure named PrintInvoice that resides in a standard module named Utilities, and there's also a button on the same form named PrintInvoice, use the fully qualified name Utilities.PrintInvoice when you call the procedure from your form or form module .
When you create a field in a table that will be bound to a control on a report or used in an expression in the ControlSource property of a control or a report, avoid assigning the field a name that's the same name as a method of the Application object. To see a list of methods of the Application object, click Object Browser on the View menu while in module Design view . Click Access in the Project/Library box, click Application in the Classes box, and view the methods of the Application object in the Members Of box.
When you create a field in a table that will be bound to a control on a report or used in an expression in the ControlSource property of a control or a report, avoid assigning the field a name that's the same name as a method of the Application object.
Since module-level variables retain their values until they are reset with the Reset command on the Run menu or the Reset button on the toolbar, the form will stay open if the variable has been declared as a module-level variable.
Any properties that you set will affect this instance of the form's class, but won't be saved with the form. Also, a new instance of the form's class can't be created if the form is open in Design view.
Any properties that you set will affect this instance of the form's class, but won't be saved with the form.
Also, a new instance of the form's class can't be created if the form is open in Design view.
A nondefault instance of a form's class can't be referred to by name in the Forms collection. You can refer to it by index number only. Since you can create multiple nondefault instances of a form, and each instance has the same name, you can have more than one form with the same name in the Forms collection, without any means of distinguishing them other than by index number.
A nondefault instance of a form's class can't be referred to by name in the Forms collection.
You can refer to it by index number only.
Since you can create multiple nondefault instances of a form, and each instance has the same name, you can have more than one form with the same name in the Forms collection, without any means of distinguishing them other than by index number.
Program Toolbars and Menu Bars
Microsoft Access includes command bars , which are programmable toolbars and menu bars . Using command bars, you can create custom toolbars and menus for your application.
Microsoft Access includes command bars , which are programmable toolbars and menu bars .
Using command bars, you can create custom toolbars and menus for your application.
In order to program with command bars, you must set a reference to the Microsoft Office object library. Click References on the Tools menu while in module Design view , and select the check box next to Microsoft Office Object Library .
In order to program with command bars, you must set a reference to the Microsoft Office object library.
Click References on the Tools menu while in module Design view , and select the check box next to Microsoft Office Object Library .
The CommandBars collection includes all the command bars that currently exist within the application. You can add a new CommandBar object to the CommandBars collection by using the Add method of the CommandBars collection. For example, the following code creates a new command bar named MyCommandBar. Note that you need to set the new command bar's Visible property to True in order to see it.
The CommandBars collection includes all the command bars that currently exist within the application.
You can add a new CommandBar object to the CommandBars collection by using the Add method of the CommandBars collection.
For example, the following code creates a new command bar named MyCommandBar.
Note that you need to set the new command bar's Visible property to True in order to see it.
Each CommandBar object has a CommandBarControls collection, which contains all the controls on the command bar. Command bar controls are different from the controls on a form. You can create different types of command bar controls, including buttons, combo boxes, and pop-ups. You can combine these controls to create a custom toolbar or menu bar.
Each CommandBar object has a CommandBarControls collection, which contains all the controls on the command bar.
Command bar controls are different from the controls on a form.
You can create different types of command bar controls, including buttons, combo boxes, and pop-ups.
You can combine these controls to create a custom toolbar or menu bar.
To refer to the CommandBarControls collection, use the Controls property of the CommandBar object. To add a control to a command bar, use the Add method of the CommandBarControls collection, specifying which type of control you want to create. The following example adds a new button to the command bar created in the previous example:
To refer to the CommandBarControls collection, use the Controls property of the CommandBar object.
To add a control to a command bar, use the Add method of the CommandBarControls collection, specifying which type of control you want to create.
The following example adds a new button to the command bar created in the previous example:
You can specify an expression to evaluate or a macro to run when the user clicks a command bar control. Set the OnAction to the name of a macro or to an expression that contains a built-in or user-defined function. For example, the following line of code sets the OnAction property of a CommandBarControl object to an expression that includes the MsgBox function. This example uses the CommandBar and CommandBarControl objects created in the previous two examples:
You can specify an expression to evaluate or a macro to run when the user clicks a command bar control.
Set the OnAction to the name of a macro or to an expression that contains a built-in or user-defined function.
For example, the following line of code sets the OnAction property of a CommandBarControl object to an expression that includes the MsgBox function.
This example uses the CommandBar and CommandBarControl objects created in the previous two examples:
Unlike most other collections in Microsoft Access, the CommandBars collection and all the collections it contains are indexed beginning with 1 rather than 0.
Query Field
A query field represents data from a table linked to the query. By default, a query field inherits all the properties that it has in the underlying table or query. For example, if a table design specifies the display format of the Order Date field as Medium Date in the field's Format property, the Order Date field is formatted in the query recordset as Medium Date. Because the underlying field properties are the defaults, they aren't displayed on the property sheet.
A query field represents data from a table linked to the query.
By default, a query field inherits all the properties that it has in the underlying table or query.
To create a new Reference object, use either the AddFromFile or AddFromGUID method of the References collection.
For example, the text string ABC would be stored in memory as shown below.
If programs created in a previous version of Microsoft Access are moved to the current version of Microsoft Access, consider issues discussed in the following topics regarding string processing.
Asc Function and AscB Function
Chr Function and ChrB Function
For example, if a table design specifies the display format of the Order Date field as Medium Date in the field's Format property, the Order Date field is formatted in the query recordset as Medium Date.
Because the underlying field properties are the defaults, they aren't displayed on the property sheet.
If a field property is changed in the table design, the query field automatically inherits the change. If, however, you change a property within the query, the property setting within the table design is overridden. If the property is later changed in the table design, the change isn't reflected in the query.
You can set the properties for query fields within the Field Properties window of the query Design view.
To open the Field Properties window in query Design view for a query field, click Properties on the Query Design toolbar .
Report Section
A report section is part of a report such as a header, footer, or detail section.
You can set report section properties that are attributes of a report which affect the appearance or behavior of a specific section. For example, you can set the CanGrow property to specify whether the section will increase vertically to print all the data the section contains. Section properties are set in report Design view .
You can set report section properties that are attributes of a report which affect the appearance or behavior of a specific section.
Section properties are set in report Design view .
A report is a Microsoft Access database object that presents information formatted and organized according to your specifications. Examples of reports are sales summaries, phone lists, and mailing labels.
A report is a Microsoft Access database object that presents information formatted and organized according to your specifications.
Examples of reports are sales summaries, phone lists, and mailing labels.
Scoping and Object-Naming Compatibility
Visual Basic scoping rules affect the names you choose for your objects, modules , and procedures .
Modules and Other Objects with the Same Name
When you name a module, avoid prefacing module names with Form_ or Report_. Naming a module in this way could conflict with existing code you've written behind forms and reports.
If you have a module in an application created with version 1. x or 2.0 of Microsoft Access that doesn't follow these naming rules, Microsoft Access generates an error when you try to convert your application. For example, a module named Form_Orders in a Microsoft Access version 1. x or 2.0 database would generate an error and you would be asked to rename the module before attempting to convert it.
If you have a module in an application created with version 1. x or 2.0 of Microsoft Access that doesn't follow these naming rules, Microsoft Access generates an error when you try to convert your application.
For example, a module named Form_Orders in a Microsoft Access version 1. x or 2.0 database would generate an error and you would be asked to rename the module before attempting to convert it.
Modules and Procedures with the Same Name
Although it is not suggested, you can have a procedure with the same name as a module. To call that procedure from an expression anywhere in your application, you must use a fully qualified name for the procedure, including both the module name and the procedure name, as in the following example:
Although it is not suggested, you can have a procedure with the same name as a module.
To call that procedure from an expression anywhere in your application, you must use a fully qualified name for the procedure, including both the module name and the procedure name, as in the following example:
This will not work with the Runcode action in macros. Accessing procedures with the same name as a module is not possible with macros.
Procedures and Controls with the Same Name
If you call a procedure from a form, and that procedure has the same name as a control on the form, you must fully qualify the procedure call with the name of the module in which it resides. For example, if you want to call a procedure named PrintInvoice that resides in a standard module named Utilities, and there's also a button on the same form named PrintInvoice, use the fully qualified name Utilities.PrintInvoice when you call the procedure from your form or form module .
If you call a procedure from a form, and that procedure has the same name as a control on the form, you must fully qualify the procedure call with the name of the module in which it resides.
To set a reference from Visual Basic, you create a new Reference object representing the desired reference. The References collection contains all currently set references.
To set a reference from Visual Basic, you create a new Reference object representing the desired reference.
The References collection contains all currently set references.
To create a new Reference object, use either the AddFromFile or AddFromGUID method of the References collection. To remove a Reference object, use the Remove method.
For example, if you want to call a procedure named PrintInvoice that resides in a standard module named Utilities, and there's also a button on the same form named PrintInvoice, use the fully qualified name Utilities.PrintInvoice when you call the procedure from your form or form module .
Controls with Similar Names
You can't have a control with a name that differs from an existing control's name by only a space or a symbol. For example, if you have a control named [Last_Name], you can't have a control named [Last Name] or [Last+Name].
You can't have a control with a name that differs from an existing control's name by only a space or a symbol.
For example, if you have a control named [Last_Name], you can't have a control named [Last Name] or [Last+Name].
Modules with the Same Names as Type Libraries
You can't save a module with the same name as a type library . If you try to save a module with the name ADO, Access, DAO or VBA, you'll get an error stating that the name conflicts with an existing module, project, or object library . Similarly, if you've set a reference to another type library, such as the Microsoft Excel type library, you can't save a module with the name Excel.
Each Microsoft Access database includes a Visual Basic project . The Visual Basic project is the set of all modules in the project, including both standard modules and class modules . Every Microsoft Access database, library database , or add-in contained in an .mde file includes a Visual Basic project.
On the Tools menu, click References . The References command on the Tools menu is available only when a Module window is open and active in Design view .
The References command on the Tools menu is available only when a Module window is open and active in Design view .
You can't save a module with the same name as a type library .
If you try to save a module with the name ADO, Access, DAO or VBA, you'll get an error stating that the name conflicts with an existing module, project, or object library .
Similarly, if you've set a reference to another type library, such as the Microsoft Excel type library, you can't save a module with the name Excel.
Fields with the Same Names as Methods
If a field in the table has the same name as an ActiveX Data Objects (ADO) method on an ADO Recordset object, or a Data Access Object (DAO) method on a DAO Recordset object, you can't refer to the corresponding field in the recordset with the . (dot) syntax. You must use the ! (exclamation point) syntax, or Microsoft Access will generate an error. The following example shows how to refer to a field called AddNew in a recordset opened on a table called Contacts:
Modules with the Same Names as Visual Basic Functions
If you save a module with the same name as an intrinsic Visual Basic function, Microsoft Access will generate an error when you try to run that function. For example, if you save a module named MsgBox, and then try to run a procedure that calls the MsgBox function, Microsoft Access generates the error Expected variable or procedure, not module.
If you save a module with the same name as an intrinsic Visual Basic function, Microsoft Access will generate an error when you try to run that function.
For example, if you save a module named MsgBox, and then try to run a procedure that calls the MsgBox function, Microsoft Access generates the error Expected variable or procedure, not module.
Modules with the Same Names as Objects
If a database created with a previous version of Microsoft Access includes a module that has the same name as a Microsoft Access object, an ADO object, or a DAO object, you may encounter compilation errors when you convert your database. For example, a module named Form or Database may generate a compilation error. To avoid these errors, rename the module.
If a database created with a previous version of Microsoft Access includes a module that has the same name as a Microsoft Access object, an ADO object, or a DAO object, you may encounter compilation errors when you convert your database.
For example, a module named Form or Database may generate a compilation error.
To avoid these errors, rename the module.
Naming Fields Used in Expressions or Bound to Controls on Forms and Reports
When you create a field in a table that will be bound to a control on a report or used in an expression in the ControlSource property of a control or a report, avoid assigning the field a name that's the same name as a method of the Application object. To see a list of methods of the Application object, click Object Browser on the View menu while in module Design view . Click Access in the Project/Library box, click Application in the Classes box, and view the methods of the Application object in the Members Of box.
To see a list of methods of the Application object, click Object Browser on the View menu while in module Design view .
Click Access in the Project/Library box, click Application in the Classes box, and view the methods of the Application object in the Members Of box.
When you create a field in a table that will be bound to a control on a form or report, avoid assigning the field any of the following names: AddRef, GetIDsOfNames, GetTypeInfo, GetTypeInfoCount, Invoke, QueryInterface, or Release.
Identifiers with Same Names as Visual Basic Keywords
The version of Visual Basic that's used by Microsoft Access 97 (and later) contains some new Visual Basic keywords, so you can no longer use these keywords as identifiers. These keywords are: AddressOf , Assert , Decimal , DefDec , Enum , Event , Friend , Implements , RaiseEvent , and WithEvents . When you convert a database developed with a prior version of Microsoft Access, existing identifiers that are the same as a new Visual Basic keyword will cause a compile error. To correct this problem, rename the identifiers.
The version of Visual Basic that's used by Microsoft Access 97 (and later) contains some new Visual Basic keywords, so you can no longer use these keywords as identifiers.
These keywords are: AddressOf , Assert , Decimal , DefDec , Enum , Event , Friend , Implements , RaiseEvent , and WithEvents .
When you convert a database developed with a prior version of Microsoft Access, existing identifiers that are the same as a new Visual Basic keyword will cause a compile error.
To correct this problem, rename the identifiers.
Project Names the Same as Microsoft Access Objects
A project name is the string that is the name of your Microsoft Access application. In prior versions of Microsoft Access, the project name was the name of the database. Beginning in Microsoft Access 2000, the project name is specified by the ProjectName property setting and its default setting is the name of the database. If you convert a database with a name that is the same as a class of objects, for example, application, form, or report, Microsoft Access will append an underscore character to the database name to create a project name that does not conflict with existing objects.
A project name is the string that is the name of your Microsoft Access application.
In prior versions of Microsoft Access, the project name was the name of the database.
Beginning in Microsoft Access 2000, the project name is specified by the ProjectName property setting and its default setting is the name of the database.
If you convert a database with a name that is the same as a class of objects, for example, application, form, or report, Microsoft Access will append an underscore character to the database name to create a project name that does not conflict with existing objects.
Set a Reference to a Visual Basic Project in Another Microsoft Access Database or Project
Each Microsoft Access database (.mdb or .adp) includes a Visual Basic project . The Visual Basic project is the set of all modules in the project, including both standard modules and class modules . Every Microsoft Access database (.mdb or .adp), library database , or add-in contained in an .mde file includes a Visual Basic project.
The name of the Access database and the name of the project can differ. The name of the Access database is determined by the name of the .mdb (or .mda or .mde) or .adp file, while the name of the project is determined by the setting of the Project Name option on the General tab of the ProjectName - Project Properties dialog box, available by clicking ProjectName Properties on the Tools menu in the Visual Basic Editor. When you first create a database (.mdb or .adp), the database name and project name are the same by default. However, if you rename the database, the project name doesn't automatically change. Likewise, changing the project name has no effect on the database name.
The name of the Access database and the name of the project can differ.
The name of the Access database is determined by the name of the .mdb (or .mda or .mde) or .adp file, while the name of the project is determined by the setting of the Project Name option on the General tab of the ProjectName - Project Properties dialog box, available by clicking ProjectName Properties on the Tools menu in the Visual Basic Editor.
When you first create a database (.mdb or .adp), the database name and project name are the same by default.
However, if you rename the database, the project name doesn't automatically change.
Likewise, changing the project name has no effect on the database name.
You can set a reference from a Visual Basic project in one Microsoft Access database to a project in another Microsoft Access database, a library database, or an add-in contained in an .mde file. Once you've set a reference, you can run Visual Basic procedures in the referenced project. For example, the Northwind sample database includes a module named Utility Functions that contains a function called IsLoaded. You can set a reference to the project in the Northwind sample database from the project in the current database, and then call the IsLoaded function just as you would if it were defined within the current database.
You can set a reference from a Visual Basic project in one Microsoft Access database to a project in another Microsoft Access database, a library database, or an add-in contained in an .mde file.
Once you've set a reference, you can run Visual Basic procedures in the referenced project.
For example, the Northwind sample database includes a module named Utility Functions that contains a function called IsLoaded.
You can set a reference to the project in the Northwind sample database from the project in the current database, and then call the IsLoaded function just as you would if it were defined within the current database.
To set a reference to the project in the Northwind sample database from another project:
Open the Module window.
On the Tools menu, click References , and click Browse in the References dialog box.
In the Files Of Type box, click Microsoft Access Databases (*.mdb) .
Locate the Northwind.mdb file. If you've installed this file, it will be in the \Program Files\Microsoft Office\Office\Samples folder by default.
Click OK .
You should now see Northwind.mdb in the list of available references in the References dialog box.
Set a reference to the project in another Microsoft Access database when you want to call a public procedure that's defined within a standard module in that database. You can't call procedures that are defined within a class module or procedures in a standard module that are preceded with the Private keyword.
Set a reference to the project in another Microsoft Access database when you want to call a public procedure that's defined within a standard module in that database.
You can't call procedures that are defined within a class module or procedures in a standard module that are preceded with the Private keyword.
You can set a reference to the project in a Microsoft Access database only from another Microsoft Access database.
You can set a reference to a project only in another Microsoft Access 2002 or later database. To set a reference to a project in a database created in an earlier version of Microsoft Access, first convert that database to Microsoft Access 2002 or later.
You can set a reference to a project only in another Microsoft Access 2002 or later database.
To set a reference to a project in a database created in an earlier version of Microsoft Access, first convert that database to Microsoft Access 2002 or later.
If you set a reference to a project or type library from Microsoft Access and then move the file that contains that project or type library to a different folder, Microsoft Access will attempt to locate the file and reestablish the reference. If the RefLibPaths key exists in the registry, Microsoft Access will first search there. If there's no matching entry, Microsoft Access will search for the file first in the current folder, then in all the folders on the drive. You can create the RefLibPaths key by using the Registry Editor in Windows, under the registry key \HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Office\ version \Access. For more information about using the Registry Editor, see your Windows documentation.
If you set a reference to a project or type library from Microsoft Access and then move the file that contains that project or type library to a different folder, Microsoft Access will attempt to locate the file and reestablish the reference.
If the RefLibPaths key exists in the registry, Microsoft Access will first search there.
If there's no matching entry, Microsoft Access will search for the file first in the current folder, then in all the folders on the drive.
You can create the RefLibPaths key by using the Registry Editor in Windows, under the registry key \HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Office\ version \Access.
For more information about using the Registry Editor, see your Windows documentation.
Set References to Type Libraries
When you set a reference to another application's type library , you can use the objects supplied by that application in your code. For example, if you set a reference from Microsoft Access to the Microsoft Excel library, you can then use Microsoft Excel objects through Automation (formerly called OLE Automation). If you set a reference to a Visual Basic project in another Microsoft Access database, you can call its public procedures. If you set a reference to an ActiveX control , you can use that control on Microsoft Access forms.
When you set a reference to another application's type library , you can use the objects supplied by that application in your code.
For example, if you set a reference from Microsoft Access to the Microsoft Excel library, you can then use Microsoft Excel objects through Automation (formerly called OLE Automation).
If you set a reference to a Visual Basic project in another Microsoft Access database, you can call its public procedures.
If you set a reference to an ActiveX control , you can use that control on Microsoft Access forms.
You can set a reference from Microsoft Access while the Microsoft Visual Basic Editor is open, or you can set a reference in Visual Basic code.
Setting a Reference from Microsoft Access
To set a reference to an application's type library:
On the Tools menu, click References . The References command on the Tools menu is available only when a Module window is open and active in Design view .
On the Tools menu, click References .
The References command on the Tools menu is available only when a Module window is open and active in Design view .
Select the check boxes for those applications whose type libraries you want to reference.
Setting a Reference from Visual Basic
To set a reference from Visual Basic, you create a new Reference object representing the desired reference. The References collection contains all currently set references.
The References collection contains all currently set references.
To remove a Reference object, use the Remove method.
Advantages of Setting References
Your Automation code will run faster if you set a reference to another application's type library before you work with its objects. If you've set a reference, you can declare an object variable representing an object in the other application as its most specific type. For example, if you're writing code to work with Microsoft Excel objects, you can declare an object variable of type Excel.Application by using the following syntax only if you've created a reference to the Microsoft Excel type library:
Your Automation code will run faster if you set a reference to another application's type library before you work with its objects.
If you've set a reference, you can declare an object variable representing an object in the other application as its most specific type.
For example, if you're writing code to work with Microsoft Excel objects, you can declare an object variable of type Excel.Application by using the following syntax only if you've created a reference to the Microsoft Excel type library:
If you haven't set a reference to the Microsoft Excel type library, you must declare the variable as a generic variable of type Object . The following code runs more slowly:
If you haven't set a reference to the Microsoft Excel type library, you must declare the variable as a generic variable of type Object .
The following code runs more slowly:
Additionally, if you set a reference to an application's type library, all of its objects, as well as their methods and properties, are listed in the Object Browser . This makes it easy to determine what properties and methods are available to each object.
Additionally, if you set a reference to an application's type library, all of its objects, as well as their methods and properties, are listed in the Object Browser .
This makes it easy to determine what properties and methods are available to each object.
Since Microsoft Access is an COM component that supports Automation, you can also set a reference to its type library from another application and work with Microsoft Access objects from that application.
Snapshot Viewer Control
An ActiveX control (Snapview.ocx) that you use to view a snapshot report from Microsoft Internet Explorer version 3.0 or later, or from any application that supports ActiveX controls, such as Microsoft Access or Microsoft Visual Basic for Applications.
Sorting And Grouping Box
The Sorting And Grouping box specifies the order of your data and define the group levels for a report.
To display the Sorting And Grouping box, click Sorting And Grouping on the toolbar .
Differences in String Function Operations
The memory storage formats for text differ between Visual Basic for Applications (VBA) code and Access Basic code. (Access Basic was used in early versions of Microsoft Access.) Text is stored in ANSI format within Access Basic code and in Unicode format in Visual Basic.
The Unicode format is used in Visual Basic to match the format of text within OLE, which is indirectly related to Visual Basic.
Storage format
Storage pattern
Description
Each character is stored as 2 bytes.
ASCII characters are stored as 1 byte; double-byte characters are stored as 2 bytes.
Because of these differences in internal format, there are string processing functions that operate differently in Access Basic and Visual Basic. The functions that operate differently and their statements are as shown below.
Because of these differences in internal format, there are string processing functions that operate differently in Access Basic and Visual Basic.
The functions that operate differently and their statements are as shown below.
Asc function, Chr function, InputB function, InStrB function, LeftB function, LenB function, RightB function, MidB function, and their corresponding statements.
Also, the ChrB function and AscB function have been added to Visual Basic.
In that these functions and statements both process text in byte units, they are the same in Access Basic and Visual Basic, but because their storage formats for text are different, they operate differently. For example, LenB (A) would be 1 in Access Basic, but 2 in Visual Basic.
In that these functions and statements both process text in byte units, they are the same in Access Basic and Visual Basic, but because their storage formats for text are different, they operate differently.
For example, LenB (A) would be 1 in Access Basic, but 2 in Visual Basic.
Programs created in previous versions of Microsoft Access that use the string processing functions that work in byte units must be changed in Visual Basic to a source code that recognizes Unicode. However, if only string processing functions that process character units, such as the Len function, Left function, and Right function, are used, there is no need to recognize them.
Programs created in previous versions of Microsoft Access that use the string processing functions that work in byte units must be changed in Visual Basic to a source code that recognizes Unicode.
However, if only string processing functions that process character units, such as the Len function, Left function, and Right function, are used, there is no need to recognize them.
If programs created in a previous version of Microsoft Access are moved to the current version of Microsoft Access, consider the following points regarding string processing.
Asc Function and AscB Function
This program ran properly in previous versions of Access, but produces a run-time error in the current version of Visual Basic in Microsoft Access.
This is because MidB ( , 2,1), an argument of the Asc function, does not correctly return data to Unicode text.
Calling the Windows API (Differences in String Function Operations)
Use the following AscB function to make this program run in the current version Microsoft Access:
In this program, the value (&H30) of the second Unicode byte is returned.
Chr Function and ChrB Function
The Chr function in Microsoft Access always returns 2-byte characters. In previous versions of Microsoft Access, Chr (&H41) and ChrB (&H41) were equal, but in the current version of Microsoft Access, Chr (&H41) and ChrB (&H41) + ChrB (0) are equal.
The Chr function in Microsoft Access always returns 2-byte characters.
In previous versions of Microsoft Access, Chr (&H41) and ChrB (&H41) were equal, but in the current version of Microsoft Access, Chr (&H41) and ChrB (&H41) + ChrB (0) are equal.
Also, in previous versions of Microsoft Access, was expressed as ChrB (&H82) + ChrB (&HA0), but in the current version of Microsoft Access it is expressed as ChrB (&H42) + ChrB (&H30).
Calling the Windows Application Programming Interface (API)
In several Windows API functions, the byte length of a string has a special meaning. For example, the following program returns a folder set up in Windows. In Microsoft Access, LeftB (Buffer, ret) does not return the correct string. This is because, in spite of the fact that it shows the byte length of an ANSI string, the LeftB function processes Unicode strings. In this case, use the InStr function so that only the character string, without nulls, is returned.
In several Windows API functions, the byte length of a string has a special meaning.
For example, the following program returns a folder set up in Windows.
In Microsoft Access, LeftB (Buffer, ret) does not return the correct string.
This is because, in spite of the fact that it shows the byte length of an ANSI string, the LeftB function processes Unicode strings.
In this case, use the InStr function so that only the character string, without nulls, is returned.
Input Function and InputB Function
The Input function in Microsoft Access converts the number of characters designated when the text is read from the file into a Unicode string and reads them as variables. The InputB function, on the other hand, assumes the data to be binary data and stores it as variables without converting it. If the InputB function is used when reading a file stored in a fixed length field, the fixed byte length data must be converted once it is read.
The Input function in Microsoft Access converts the number of characters designated when the text is read from the file into a Unicode string and reads them as variables.
The InputB function, on the other hand, assumes the data to be binary data and stores it as variables without converting it.
If the InputB function is used when reading a file stored in a fixed length field, the fixed byte length data must be converted once it is read.
Processing ANSI string bytes in Microsoft Access 7.0
If it is necessary to process ANSI string bytes in Microsoft Access, use the StrConv function. You can convert text between ANSI and Unicode by setting the vbUnicode or vbFromUnicode constant. If you process bytes after temporarily converting a string to an ANSI string, and then reconvert it back to Unicode once the process is finished, you can use codes from previous versions of Access relatively easily.
If it is necessary to process ANSI string bytes in Microsoft Access, use the StrConv function.
You can convert text between ANSI and Unicode by setting the vbUnicode or vbFromUnicode constant.
If you process bytes after temporarily converting a string to an ANSI string, and then reconvert it back to Unicode once the process is finished, you can use codes from previous versions of Access relatively easily.
Sample Functions that perform operations that are compatible with byte processing functions of 16-bit versions
In Visual Basic for Applications, the internal processing of strings is performed using Unicode. Thus, the binary processing functions in VBA are different from those of Access Basic, which was used in early versions of Microsoft Access.
In Visual Basic for Applications, the internal processing of strings is performed using Unicode.
Thus, the binary processing functions in VBA are different from those of Access Basic, which was used in early versions of Microsoft Access.
The ANSI function was created to preserve compatibility between the operations of Access Basic and Visual Basic.
Strings input and removed with these ANSI processing functions are always Unicode. After being converted temporarily to ANSI strings within the function, they are restored to Unicode once the process is finished.
Strings input and removed with these ANSI processing functions are always Unicode.
After being converted temporarily to ANSI strings within the function, they are restored to Unicode once the process is finished.
The following cannot combine the first and second byte of a DBCS character to create a DBCS character.
These functions have been created to process strings in byte units. However, a different character cannot be created by the byte-unit processing. In this case, it would be expressed as follows:
These functions have been created to process strings in byte units.
However, a different character cannot be created by the byte-unit processing.
In this case, it would be expressed as follows:
Generally, if you convert a string to an ANSI character before processing, you should restore the converted string to a Unicode character after the process is finished.
A byte string process is always a function for processing a string. To process binary data, use a byte Array, not a string variable or a byte string processing function.
A byte string process is always a function for processing a string.
To process binary data, use a byte Array, not a string variable or a byte string processing function.
A string stored in a byte Array appears as follows:
Using the Byte data type
In Microsoft Access, the Byte data type has been added as a new data type. If a string variable is used when processing binary data, text is converted between ANSI and Unicode, and binary data is changed. Thus, when dealing with binary data, use Byte data type variables.
In Microsoft Access, the Byte data type has been added as a new data type.
If a string variable is used when processing binary data, text is converted between ANSI and Unicode, and binary data is changed.
Thus, when dealing with binary data, use Byte data type variables.
Table Field
Table fields are separate pieces of information that make up a record within a table. You can control the appearance of data, specify default values, and speed up searching and sorting by setting field properties in the Field Properties section of table Design view .
Table fields are separate pieces of information that make up a record within a table.
You can control the appearance of data, specify default values, and speed up searching and sorting by setting field properties in the Field Properties section of table Design view .
Microsoft Access uses field properties when you view or edit data. For example, the Format , InputMask , and Caption properties that you set affect the appearance of table and query databases. The controls on new forms and reports that are based on the table inherit these properties by default. You can use other properties to set rules for data or to require data entry in your fields, which Microsoft Access enforces whenever you add or edit data in a table.
To open a table in Design view, go to the Database window , click the Tables tab, select the table you want to open, and then click Design .
Table
A table is the fundamental structure of a relational database management system. In Microsoft Access, a table is an object that stores data in records (rows) and fields (columns). The data is usually about a particular category of things, such as employees or orders.
A table is the fundamental structure of a relational database management system.
In Microsoft Access, a table is an object that stores data in records (rows) and fields (columns).
The data is usually about a particular category of things, such as employees or orders.
Using Enumerated Constants in Microsoft Access 2002 and Later
In Microsoft Access 2002, a number of intrinsic constants were added or changed. This was done to create lists of enumerated constants that are displayed in the Auto List Members list in the Module window for the arguments of various Microsoft Access methods , functions, and properties, or as the setting of various Microsoft Access properties. You can select the appropriate constant from the list in the Module window, instead of having to remember the constant or look it up in the Help topic.
The following information applies to enumerated constants:
The set of enumerated constants for each method, function, or property argument has a name, which is displayed in the syntax line for the method, function, or property in the Module window when the Auto Quick Info option is selected in the Editor tab of the Options dialog box, available by clicking Options on the Tool menu. (For property settings, the name isn't displayed, just the list of constants.) For example, the syntax line for the OpenForm method of the DoCmd object shows [View As AcFormView = acNormal] for the view argument of this method. AcFormView is the name of this set of enumerated constants, and acNormal is the default setting for the argument. The Object Browser also lists the names of the sets of enumerated constants in the Classes box and lists the intrinsic constants contained in each of these sets in the Members Of box.
The set of enumerated constants for each method, function, or property argument has a name, which is displayed in the syntax line for the method, function, or property in the Module window when the Auto Quick Info option is selected in the Editor tab of the Options dialog box, available by clicking Options on the Tool menu.
(For property settings, the name isn't displayed, just the list of constants.)
For example, the syntax line for the OpenForm method of the DoCmd object shows [View As AcFormView = acNormal] for the view argument of this method.
AcFormView is the name of this set of enumerated constants, and acNormal is the default setting for the argument.
The Object Browser also lists the names of the sets of enumerated constants in the Classes box and lists the intrinsic constants contained in each of these sets in the Members Of box.
In addition to the constants you declare with the Const statement, Microsoft Access automatically declares a number of intrinsic constants and provides access to the Visual Basic for Applications (VBA) constants, and ActiveX Data Objects (ADO) constants. You can also use constants in other referenced object libraries. For more information on adding references see Set References to Type Libraries .
For constant names that have changed, the old constants will still work. For example, one of the intrinsic constants for the save argument of the Close method of the DoCmd object was acPrompt . It's now acSavePrompt , but acPrompt will still work.
For constant names that have changed, the old constants will still work.
For example, one of the intrinsic constants for the save argument of the Close method of the DoCmd object was acPrompt .
It's now acSavePrompt , but acPrompt will still work.
In a number of cases in previous versions of Microsoft Access, you could leave an argument setting blank, and Microsoft Access would perform the default action for that argument. For example, you could leave the objecttype (and objectname ) arguments of the Close method blank, and Microsoft Access would close the active window. For the new sets of enumerated constants, the blank setting has been replaced with a new default constant. For example, the objecttype argument of the Close method now has a new default constant, acDefault . Setting this argument to the new constant has the same effect as leaving the argument blank. In addition, you can still leave such arguments blank, and Microsoft Access will assume the new default constant.
In a number of cases in previous versions of Microsoft Access, you could leave an argument setting blank, and Microsoft Access would perform the default action for that argument.
For example, you could leave the objecttype (and objectname ) arguments of the Close method blank, and Microsoft Access would close the active window.
For the new sets of enumerated constants, the blank setting has been replaced with a new default constant.
For example, the objecttype argument of the Close method now has a new default constant, acDefault .
Setting this argument to the new constant has the same effect as leaving the argument blank.
In addition, you can still leave such arguments blank, and Microsoft Access will assume the new default constant.
There's one exception to this. If you run Visual Basic code from previous versions of Visual Basic in Microsoft Access by using Automation , blank arguments will cause an error for those arguments that have the new default constants. This problem doesn't occur for old Visual Basic for Applications or Visual Basic code run directly in Microsoft Access.
There's one exception to this.
If you run Visual Basic code from previous versions of Visual Basic in Microsoft Access by using Automation , blank arguments will cause an error for those arguments that have the new default constants.
This problem doesn't occur for old Visual Basic for Applications or Visual Basic code run directly in Microsoft Access.
Microsoft Access Constants - Overview
General
A constant represents a numeric or string value that doesn't change. You can use constants to improve the readability of your Visual Basic code and to make your code easier to maintain. In addition, the use of intrinsic constants ensures that code will continue to work even if the underlying values that the constants represent are changed in later releases of Microsoft Access.
A constant represents a numeric or string value that doesn't change.
You can use constants to improve the readability of your Visual Basic code and to make your code easier to maintain.
In addition, the use of intrinsic constants ensures that code will continue to work even if the underlying values that the constants represent are changed in later releases of Microsoft Access.
Microsoft Access supports three types of constants:
Symbolic constants, which you create by using the Const statement and use in modules .
Intrinsic constants, which are part of Microsoft Access or a referenced library.
System-defined constants: True , False , and Null .
Symbolic Constants
Often, you'll use the same values repeatedly in your code, or you'll find that the code depends on certain numbers that have no obvious meaning. In these cases, you can make the code much easier to read and maintain by using symbolic or user-defined constants, which enable you to use a meaningful name in place of a number or string.
Often, you'll use the same values repeatedly in your code, or you'll find that the code depends on certain numbers that have no obvious meaning.
In these cases, you can make the code much easier to read and maintain by using symbolic or user-defined constants, which enable you to use a meaningful name in place of a number or string.
Once you have created a constant by using the Const statement, you can't modify it or assign a new value to it. You also can't create a constant that has the same name as an intrinsic constant.
Once you have created a constant by using the Const statement, you can't modify it or assign a new value to it.
You also can't create a constant that has the same name as an intrinsic constant.
The following examples show some of the ways you can use the Const statement to declare numeric and string constants:
Intrinsic Constants
In addition to the constants you declare with the Const statement, Microsoft Access automatically declares a number of intrinsic constants and provides access to the Visual Basic for Applications (VBA) constants, and ActiveX Data Objects (ADO) constants. You can also use constants in other referenced object libraries. For more information on adding references see Setting References to Type Libraries .
In addition to the constants you declare with the Const statement, Microsoft Access automatically declares a number of intrinsic constants and provides access to the Visual Basic for Applications (VBA) constants, and ActiveX Data Objects (ADO) constants.
You can also use constants in other referenced object libraries.
For more information on adding references see Setting References to Type Libraries .
Any intrinsic constant can be used in a macro or Visual Basic. These constants are available at all times. The specific built-in constants used with a particular function, method, or property are described in the Help topic for that function, method, or property.
Any intrinsic constant can be used in a macro or Visual Basic.
These constants are available at all times.
The specific built-in constants used with a particular function, method, or property are described in the Help topic for that function, method, or property.
You can use the Object Browser to view lists of intrinsic constants from all available object libraries.
Intrinsic constants have a two letter prefix identifying the object library that defines the constant. Constants from the Microsoft Access library are prefaced with ac; constants from the ADO library are prefaced with ad; and constants from the Visual Basic library are prefaced with vb. For example:
Intrinsic constants have a two letter prefix identifying the object library that defines the constant.
Constants from the Microsoft Access library are prefaced with ac; constants from the ADO library are prefaced with ad; and constants from the Visual Basic library are prefaced with vb.
For example:
If criteria is composed of a string concatenated with a non-integer value, and the system parameters specify a non-U.S. decimal character such as a comma (for example, strSQL = PRICE > & lngPrice , and lngPrice = 125,50 ), an error occurs when you try to call the method. This is because during concatenation, the number will be converted to a string using your system's default decimal character, and Microsoft Access SQL only accepts U.S. decimal characters.
Because the values represented by the intrinsic constants may change in future versions of Microsoft Access, you should use the constants instead of their actual values. You can, however, display the actual value of a constant by choosing the constant in the Object Browser or by typing ? constantname in the Immediate window .
Because the values represented by the intrinsic constants may change in future versions of Microsoft Access, you should use the constants instead of their actual values.
You can, however, display the actual value of a constant by choosing the constant in the Object Browser or by typing ? constantname in the Immediate window .
You can use intrinsic constants wherever you can use symbolic, or user-defined constants, including in expressions . The following example shows how you might use the intrinsic constant vbCurrency to determine whether the variable varNum is a Variant for which the VarType function returns 6 ( Currency ):
You can use intrinsic constants wherever you can use symbolic, or user-defined constants, including in expressions .
The following example shows how you might use the intrinsic constant vbCurrency to determine whether the variable varNum is a Variant for which the VarType function returns 6 ( Currency ):
System-Defined Constants
You can use the system-defined constants True , False , and Null anywhere in Microsoft Access. For example, you can use True in the following macro condition expression. The condition is met if the Visible property setting for the Employees form equals True .
You can use the system-defined constants True , False , and Null anywhere in Microsoft Access.
For example, you can use True in the following macro condition expression.
The condition is met if the Visible property setting for the Employees form equals True .
You can use the constant Null anywhere in Microsoft Access. For example, you can use Null to set the DefaultValue property for a form control by using the following expression:
You can use the constant Null anywhere in Microsoft Access.
For example, you can use Null to set the DefaultValue property for a form control by using the following expression:
Action Query
An action query changes data or copies data. Action queries include append, delete, make-table, and update queries. In contrast, a select query doesn't copy or change data; it simply returns a set of records.
Action query type
Append
Adds the records in a query's result set to the end of an existing table.
Delete
Deletes a set of rows that match the criteria you specify.
Make-Table
Creates a new table from the result set of an existing query.
Update
Changes a set of records according to criteria you specify.
Understanding ActiveX Controls (Data Access Pages)
In addition to the built-in controls that appear in the toolbox, Microsoft Access supports ActiveX controls (formerly known as custom or OLE controls). An ActiveX control, like a built-in control, is an object that you place on a form to enable or enhance a user's interaction with an application. ActiveX controls have events and can be incorporated into other controls. These controls have an .ocx file name extension. The Calendar control is an example of an ActiveX control.
ActiveX Control (Form)
Control :
Tool :
Calendar control
Tool button
This control should not be confused with the Dynamic HTML ActiveX control used on a data access page. For information about a ActiveXcontrol on a data access page, see ActiveX Control (Data Access Pages).
This control should not be confused with the Dynamic HTML ActiveX control used on a data access page.
For information about a ActiveXcontrol on a data access page, see ActiveX Control (Data Access Pages).
Bound Control
A bound control is a control on a form or report that gets its contents from a field in the underlying table, query, or SQL statement. (The control's ControlSource property is set to a field name in the table, query, or SQL statement.) For example, a text box that displays an employee's last name is bound to the LastName field in the Employees table.
A bound control is a control on a form or report that gets its contents from a field in the underlying table, query, or SQL statement.
(The control's ControlSource property is set to a field name in the table, query, or SQL statement.)
For example, a text box that displays an employee's last name is bound to the LastName field in the Employees table.
Bound Span Control
The bound span control can be used to store span code in a field in a table, and when the data access page displays the values in that field, the span code performs the actions that you specified. When the field or column is placed on a data access page as a bound span control, the contents of the field are rendered as span and are not editable.
You can make the bound span control the default control for a grouped data access page. Set the DefaultControlType property of the data access page to Bound Span .
You can make the bound span control the default control for a grouped data access page.
Set the DefaultControlType property of the data access page to Bound Span .
You can use a bound span control to display calculations and all data on a grouped data access page. The page will load faster in Microsoft Internet Explorer if you use span controls.
You can use a bound span control to display calculations and all data on a grouped data access page.
The page will load faster in Microsoft Internet Explorer if you use span controls.
You can't use the navigation control to sort or filter on bound span controls in Page view or in Internet Explorer.
Bound Hyperlink Control
The bound hyperlink control can add a bound hyperlink to a text field of a data access page . You can use a bound hyperlink when you want a different hyperlink address for each record in a table. As you move from record to record, you can click on the hyperlink and go to a different Web page for each record.
The bound hyperlink control can add a bound hyperlink to a text field of a data access page .
You can use a bound hyperlink when you want a different hyperlink address for each record in a table.
As you move from record to record, you can click on the hyperlink and go to a different Web page for each record.
Bound Object Frame Control
A bound object frame control displays a picture, chart , or any OLE object stored in a table in a Microsoft Access database. For example, if you store pictures of your employees in a table in Microsoft Access, you can use a bound object frame to display these pictures on a form or report.
A bound object frame control displays a picture, chart , or any OLE object stored in a table in a Microsoft Access database.
For example, if you store pictures of your employees in a table in Microsoft Access, you can use a bound object frame to display these pictures on a form or report.
Remarks
This control type allows you to create or edit the object from within the form or report by using the OLE server .
A bound object frame is bound to a field in an underlying table.
The field in the underlying table to which the bound object frame is bound must be of the OLE Object data type.
The object in a bound object frame is different for each record. The bound object frame can display linked or embedded objects. If you want to display objects not stored in an underlying table, use an unbound object frame or an image control .
The object in a bound object frame is different for each record.
The bound object frame can display linked or embedded objects.
If you want to display objects not stored in an underlying table, use an unbound object frame or an image control .
Chart Control (Forms and Reports)
You can use the chart control to embed a chart that displays Microsoft Access data from a form or report. You can then edit the chart by using Microsoft Graph from within the form or report.
You can use the chart control to embed a chart that displays Microsoft Access data from a form or report.
You can then edit the chart by using Microsoft Graph from within the form or report.
This control should not be confused with the Dynamic HTML image, hotspot image, or Office chart, or Office Spreadsheet control used on a data access page. For information about these control on a data access page, see Image , Image Hyperlink , Office Chart , or Office Spreadsheet Control (Data Access Pages).
This control should not be confused with the Dynamic HTML image, hotspot image, or Office chart, or Office Spreadsheet control used on a data access page.
For information about these control on a data access page, see Image , Image Hyperlink , Office Chart , or Office Spreadsheet Control (Data Access Pages).
When you place a chart control on a form or report, Microsoft Access displays the Chart Wizard to help you create the chart.
To embed or link a chart containing data from other applications, use an unbound object frame or bound object frame control.
Check Box Control (Data Access Pages)
A check box on a data access page is a bound control that displays a Yes/No value from an underlying record source .
Check box
Check Box control
When you select or clear a check box that's bound to a Yes/No field, Microsoft Access displays the value in the underlying table according to the field's Format property (Yes/No, True / False , or On/Off).
It's also possible to use an unbound check box in a custom dialog box to accept user input.
Check Box Control (Forms and Reports)
A check box on a form or report is a stand-alone control that display a Yes/No value from an underlying record source .
This control should not be confused with the Dynamic HTML check box control used on a data access page. For information about a check box control on a data access page, see Check Box Control (Data Access Pages).
This control should not be confused with the Dynamic HTML check box control used on a data access page.
For information about a check box control on a data access page, see Check Box Control (Data Access Pages).
When you select or clear a check box that's bound to a Yes/No field, Microsoft Access displays the value in the underlying table according to the field's Format property (Yes/No, True/False, or On/Off).
Combo Box Control (Forms)
The combo box control combines the features of a text box and a list box . Use a combo box when you want the option of either typing a value or selecting a value from a predefined list.
Use a combo box when you want the option of either typing a value or selecting a value from a predefined list.
This control should not be confused with the Dynamic HTML drop-down list box control used on a data access page. For information about a drop-down list box control on a data access page, see Drop-down List Box Control (Data Access Page).
This control should not be confused with the Dynamic HTML drop-down list box control used on a data access page.
For information about a drop-down list box control on a data access page, see Drop-down List Box Control (Data Access Page).
In Form view , Microsoft Access doesn't display the list until you click the combo box's arrow.
If you have Control Wizards on before you select the combo box tool, you can create a combo box with a wizard. To turn Control Wizards on or off, click the Control Wizards button in the toolbox.
If you have Control Wizards on before you select the combo box tool, you can create a combo box with a wizard.
To turn Control Wizards on or off, click the Control Wizards button in the toolbox.
The setting of the LimitToList property determines whether you can enter values that aren't in the list.
The CurrentProject object refers to the project for the current Microsoft Access project (.adp) or Access database .
CommandButton Object
The list can be single- or multiple-column, and the columns can appear with or without headings.
Command Button Control (Data Access Pages)
A command button on a data access page can start an action or a set of actions. On a data access page, code written in either JavaScript or Visual Basic Script is attached to a command button using the Microsoft Visual Script Editor .
A command button on a data access page can start an action or a set of actions.
On a data access page, code written in either JavaScript or Visual Basic Script is attached to a command button using the Microsoft Visual Script Editor .
Command button
Command Button control
You can display text on a command button by setting its Value property.
Command Button Control (Forms)
A command button on a form can start an action or a set of actions. For example, you could create a command button that opens another form. To make a command button do something, you write a macro or event procedure and attach it to the button's OnClick property.
A command button on a form can start an action or a set of actions.
For example, you could create a command button that opens another form.
To make a command button do something, you write a macro or event procedure and attach it to the button's OnClick property.
When you select an option in an option group, Microsoft Access sets the value of the field to which the option group is bound to the value of the selected option's OptionValue property.
Pages ( pagename )
A crosstab query computes summary totals based on values for each row and column. It calculates a sum, average, count, or other type of total on records, and then groups the result by two types of information  one down the left side of the datasheet and the other across the top.
Image Control
Label Control
This control should not be confused with the Dynamic HTML command button control used on a data access page. For information about a command button control on a data access page, see Command Button Control (Data Access Pages).
This control should not be confused with the Dynamic HTML command button control used on a data access page.
For information about a command button control on a data access page, see Command Button Control (Data Access Pages).
You can display text on a command button by setting its Caption property, or you can display a picture by setting its Picture property.
You can create over 30 different types of command buttons with the Command Button Wizard. When you use the Command Button Wizard, Microsoft Access creates the button and the event procedure for you.
You can create over 30 different types of command buttons with the Command Button Wizard.
When you use the Command Button Wizard, Microsoft Access creates the button and the event procedure for you.
Crosstab Query
A crosstab query computes summary totals based on values for each row and column. It calculates a sum, average, count, or other type of total on records, and then groups the result by two types of information  one down the left side of the datasheet and the other across the top. For example, the Quarterly Orders by Product query in the Northwind sample database is a crosstab query.
A crosstab query computes summary totals based on values for each row and column.
It calculates a sum, average, count, or other type of total on records, and then groups the result by two types of information  one down the left side of the datasheet and the other across the top.
For example, the Quarterly Orders by Product query in the Northwind sample database is a crosstab query.
Drop-down List Box Control (Data Access Pages)
The drop-down list box control on a data access page combines some of the features of a text box and a list box . Use a drop-down list box control when you want the option of displaying and selecting a value from a predefined list.
The drop-down list box control on a data access page combines some of the features of a text box and a list box .
Use a drop-down list box control when you want the option of displaying and selecting a value from a predefined list.
Combo box
ComboBox Tool
In Page view, Microsoft Access doesn't display the list until you click the drop-down list box control's arrow.
If you have Control Wizards on before you select the drop-down list box control tool, you can create a drop-down list box with a wizard. To turn Control Wizards on or off, click the Control Wizards tool in the toolbox.
If you have Control Wizards on before you select the drop-down list box control tool, you can create a drop-down list box with a wizard.
To turn Control Wizards on or off, click the Control Wizards tool in the toolbox.
You cannot enter values that aren't in the list.
Subform/Subreport Control
The subform/subreport control embeds a form in a form or a report in a report.
For example, you can use a form with a subform to present one-to-many relationships , such as one product category with the items that fall into that category. In this case, the main form can display the category ID, name, and description; the subform can display the available products in that category.
For example, you can use a form with a subform to present one-to-many relationships , such as one product category with the items that fall into that category.
In this case, the main form can display the category ID, name, and description; the subform can display the available products in that category.
Instead of creating the main form, and then adding the subform control to it, you can simultaneously create the main form and subform with a wizard. You can also create a subform or subreport by dragging an existing form or report from the Database window to the main form or report.
Instead of creating the main form, and then adding the subform control to it, you can simultaneously create the main form and subform with a wizard.
You can also create a subform or subreport by dragging an existing form or report from the Database window to the main form or report.
Expand Control
The expand control can add a expand/collapse button to a data access page .
Control
This control allows the user to display or hide records which have been grouped under another record.
Image Hyperlink Control
The image hyperlink control can add an unbound image to a data access page .
Image Hyperlink control
Use the image hyperlink control to add an image to a data access page that, when clicked, displays another Web page from your hard drive, the Web, or another location. When you create an image hyperlink control, you select the image to display on the page and the address of the file to jump to.
Use the image hyperlink control to add an image to a data access page that, when clicked, displays another Web page from your hard drive, the Web, or another location.
When you create an image hyperlink control, you select the image to display on the page and the address of the file to jump to.
The Insert Picture dialog box displays a list of pictures that can be selected as the image.
The Insert Hyperlink dialog box allows the user to select the file or web page that will be linked to the image control.
In Page view , as the pointer passes over the image, the pointer changes to a hand, indicating that the image is a link that you can click to go to another page. You can also define ScreenTips and alternate text for the image.
In Page view , as the pointer passes over the image, the pointer changes to a hand, indicating that the image is a link that you can click to go to another page.
You can also define ScreenTips and alternate text for the image.
Hyperlink Control (Data Access Page)
The hyperlink control can add a hyperlink to a data access page .
Button image
When the hyperlink control is placed on a data access page, Microsoft Access displays the Insert Hyperlink dialog box. The Insert Hyperlink dialog box allows the user to select the file or web page that will be linked to the hyperlink control.
Image Control (Data Access Pages)
The image control can add a picture to a data access page . For example, you could include an image control for a logo on a Sales entry page.
The image control can add a picture to a data access page .
For example, you could include an image control for a logo on a Sales entry page.
Image control
Image frame control
You can use the image control or an unbound object frame for unbound pictures. The advantage of using the image control is that it's faster to display.
You can use the image control or an unbound object frame for unbound pictures.
The advantage of using the image control is that it's faster to display.
Image Control (Forms and Reports)
The image control can add a picture to a form or report. For example, you could include an image control for a logo on an Invoice report.
The image control can add a picture to a form or report.
For example, you could include an image control for a logo on an Invoice report.
This control should not be confused with the Dynamic HTML image control used on a data access page. For information about a image control on a data access page, see Image Control (Data Access Page).
This control should not be confused with the Dynamic HTML image control used on a data access page.
For information about a image control on a data access page, see Image Control (Data Access Page).
You can use the image control or an unbound object frame for unbound pictures. The advantage of using the image control is that it's faster to display. The advantage of using the unbound object frame is that you can edit the object directly from the form or report.
Label Control (Data Access Pages)
Labels on an data access page display descriptive text such as titles, captions, or brief instructions. Labels have certain characteristics:
Labels on an data access page display descriptive text such as titles, captions, or brief instructions.
Labels have certain characteristics:
Labels don't display values from fields or expressions .
Labels don't change as you move from record to record.
Label
Label control
A label can be attached to another control. When you create a text box, for example, it has an attached label that displays a caption for that text box.
A label can be attached to another control.
When you create a text box, for example, it has an attached label that displays a caption for that text box.
When you create a label by using the Label tool, the label stands on its own it isn't attached to any other control. You use stand-alone labels for information such as the title, or for other descriptive text.
When you create a label by using the Label tool, the label stands on its own it isn't attached to any other control.
You use stand-alone labels for information such as the title, or for other descriptive text.
Label Control (Forms and Reports)
Labels on a form or report display descriptive text such as titles, captions, or brief instructions. Labels have certain characteristics:
Labels on a form or report display descriptive text such as titles, captions, or brief instructions.
Labels are always unbound .
This control should not be confused with the Dynamic HTML label control used on a data access page. For information about a label control on a data access page, see Label Control (Data Access Pages).
This control should not be confused with the Dynamic HTML label control used on a data access page.
For information about a label control on a data access page, see Label Control (Data Access Pages).
A label can be attached to another control. When you create a text box, for example, it has an attached label that displays a caption for that text box. This label appears as a column heading in the Datasheet view of a form.
This label appears as a column heading in the Datasheet view of a form.
When you create a label by using the Label tool, the label stands on its own  it isn't attached to any other control. You use stand-alone labels for information such as the title of a form or report, or for other descriptive text. Stand-alone labels don't appear in Datasheet view.
Line Control (Data Access Pages)
The line control displays a horizontal, vertical, or diagonal line on a data access page .
Line
Line control
You can use the Height property to change the line width. You can use Line/Border Color to change the color of the border or make it transparent.
Line Control (Forms and Reports)
The line control displays a horizontal, vertical, or diagonal line on a form or report.
This control should not be confused with the Dynamic HTML line control used on a data access page. For information about a line control on a data access page, see Line Control (Data Access Pages).
This control should not be confused with the Dynamic HTML line control used on a data access page.
For information about a line control on a data access page, see Line Control (Data Access Pages).
You can use Border Width to change the line width. You can use Border Color to change the color of the border or make it transparent. You can change the line style (dots, dashes, and so on) of the border by using the BorderStyle property.
List Box Control (Data Access Pages)
The list box control displays a list of values or alternatives. In many cases, it's quicker and easier to select a value from a list than to remember a value to type. A list of choices also helps ensure that the value that's entered in a field is correct.
The list box control displays a list of values or alternatives.
In many cases, it's quicker and easier to select a value from a list than to remember a value to type.
A list of choices also helps ensure that the value that's entered in a field is correct.
List box
List Box control
The list in a list box consists of rows of data.
Rows can have one or more columns, which can appear with or without headings.
Multiple-column list box
If a multiple-column list box is bound , Microsoft Access stores the values from one of the columns.
You can use an unbound list box to store a value that you can use with another control. For example, you could use an unbound list box to limit the values in another list box or in a custom dialog box . You could also use an unbound list box to find a record based on the value you select in the list box.
If you don't have room on your form to display a list box, use a dropdown box instead of a list box.
List Box Control (Forms)
This control should not be confused with the Dynamic HTML list box control used on a data access page. For information about a list box control on a data access page, see List Box Control (Data Access Pages).
This control should not be confused with the Dynamic HTML list box control used on a data access page.
For information about a list box control on a data access page, see List Box Control (Data Access Pages).
If you don't have room on your form to display a list box, or if you want to be able to type new values as well as select values from a list, use a combo box instead of a list box.
Movie Control
The movie control can add a video file (.avi or .mov) to a data access page .
Movie control
When this control is added to a data access page, the Video Browser dialog box is displayed to select the name of the movie file to be bound to this control.
You can specify whether you want the movie tobegin when the data access page is opened or when the mouse paases over the movie control.
Office Chart Control
The Office chart control can add a chart to a data access page .
Office Chart control
You can use Microsoft Office Chart, a Microsoft Office Web Component, to create dynamic, interactive charts in a data access page that you can make available on Web sites for viewing in a browser . For example, you can create a chart using data in a table that stores sales figures. When you update the sales figures, the chart updates  so users can always see the latest information on their Web pages.
You can use Microsoft Office Chart, a Microsoft Office Web Component, to create dynamic, interactive charts in a data access page that you can make available on Web sites for viewing in a browser .
For example, you can create a chart using data in a table that stores sales figures.
When you update the sales figures, the chart updates  so users can always see the latest information on their Web pages.
Microsoft Internet Explorer 5 or later is required to create a chart on a data access page, but users with Internet Explorer version 4. x or later can view the chart and see the chart updated in response to changes to data.
Office Spreadsheet Control
The Office spreadsheet control can add a spreadsheet with some of the features of a Microsoft Excel spreadsheet to a data access page .
Office Spreadsheet control
You can add a spreadsheet control to a data access page to provide some of the same capabilities you have in a Microsoft Excel worksheet. You can enter values, add formulas, apply filters, and so on. Use the procedure below to create a spreadsheet in which you enter raw data, or import data from a Web page or text file. If within the spreadsheet you want to use data from other controls on the data access page, you need to refer to those controls in the appropriate spreadsheet cells.
Option Button Control (Data Access Pages)
An option button on a data access page is a stand-alone control used to display a Yes/No value from an underlying record source
Option button
When you select or clear an option button that's bound to a Yes/No field, Microsoft Access displays the value in the underlying table according to the field's Format property (Yes/No, True / False , or On/Off).
You can also use option buttons in an option group to display values to choose from.
It's also possible to use an unbound option button in a custom dialog box to accept user input.
Option Button Control (Forms and Reports)
An option button on a form or report is a stand-alone control used to display a Yes/No value from an underlying record source
This control should not be confused with the Dynamic HTML option button control used on a data access page. For information about a option button control on a data access page, see Option Button Control (Data Access Pages).
This control should not be confused with the Dynamic HTML option button control used on a data access page.
For information about a option button control on a data access page, see Option Button Control (Data Access Pages).
Option Group Control (Data Access Pages)
An option group on a data access page displays a limited set of alternatives. An option group makes selecting a value easy since you can just click the value you want. Only one option in an option group can be selected at a time.
An option group on a data access page displays a limited set of alternatives.
An option group makes selecting a value easy since you can just click the value you want.
Only one option in an option group can be selected at a time.
An option group consists of a group frame and a set of check boxes , toggle buttons , or option buttons .
The OptionValue property is set to a number because the value of an option group can only be a number, not text. Microsoft Access stores this number in the underlying table. In the preceding example, if you want to display the name of the shipper instead of a number in the Orders table, you can create a separate table called Shippers that stores shipper names, and then make the ShipVia field in the Orders table a Lookup field that looks up data in the Shippers table.
Option group
If an option group is bound to a field, only the group frame itself is bound to the field, not the check boxes, toggle buttons, or option buttons inside the frame. Instead of setting the ControlSource property for each control in the option group, you set the Value property of each check box, toggle button, or option button to a number that's meaningful for the field to which the group frame is bound. When you select an option in an option group, Microsoft Access sets the value of the field to which the option group is bound to the value of the selected option's Value property.
If an option group is bound to a field, only the group frame itself is bound to the field, not the check boxes, toggle buttons, or option buttons inside the frame.
Instead of setting the ControlSource property for each control in the option group, you set the OptionValue property of each check box, toggle button, or option button to a number that's meaningful for the field to which the group frame is bound.
The first column lists the Type property settings available in table Design view and the five FieldSize property settings for the Number data type.
The fifth column lists the corresponding Jet database engine SQL data types defined by the Access database engine along with their valid synonyms.
Microsoft Access database engine SQL and synonyms
The INTEGER data type in the Access database engine SQL doesn't correspond to the Integer data type for table fields, query parameters, or Visual Basic. Instead, in SQL, the INTEGER data type corresponds to a Long Integer data type for table fields and query parameters and to a Long data type in Visual Basic.
Instead of setting the ControlSource property for each control in the option group, you set the Value property of each check box, toggle button, or option button to a number that's meaningful for the field to which the group frame is bound.
When you select an option in an option group, Microsoft Access sets the value of the field to which the option group is bound to the value of the selected option's Value property.
Selected option in an option group
The Value property is set to a number because the value of an option group can only be a number, not text. Microsoft Access stores this number in the underlying table. In the preceding example, if you want to display the name of the shipper instead of a number in the Orders table, you can create a separate table called Shippers that stores shipper names, and then make the ShipVia field in the Orders table a Lookup field that looks up data in the Shippers table.
The Value property is set to a number because the value of an option group can only be a number, not text.
Microsoft Access stores this number in the underlying table.
In the preceding example, if you want to display the name of the shipper instead of a number in the Orders table, you can create a separate table called Shippers that stores shipper names, and then make the ShipVia field in the Orders table a Lookup field that looks up data in the Shippers table.
An option group can also be set to an expression , or it can be unbound. You can use an unbound option group in a custom dialog box to accept user input and then carry out an action based on that input.
An option group can also be set to an expression , or it can be unbound.
You can use an unbound option group in a custom dialog box to accept user input and then carry out an action based on that input.
Option Group Control (Forms and Reports)
An option group on a form or report displays a limited set of alternatives. An option group makes selecting a value easy since you can just click the value you want. Only one option in an option group can be selected at a time.
This control should not be confused with the Dynamic HTML option group control used on a data access page. For information about a option group control on a data access page, see Option Group Control (Data Access Pages).
This control should not be confused with the Dynamic HTML option group control used on a data access page.
For information about a option group control on a data access page, see Option Group Control (Data Access Pages).
If an option group is bound to a field, only the group frame itself is bound to the field, not the check boxes, toggle buttons, or option buttons inside the frame. Instead of setting the ControlSource property for each control in the option group, you set the OptionValue property of each check box, toggle button, or option button to a number that's meaningful for the field to which the group frame is bound. When you select an option in an option group, Microsoft Access sets the value of the field to which the option group is bound to the value of the selected option's OptionValue property.
The INTEGER data type in the Access database engine SQL doesn't correspond to the Integer data type for table fields, query parameters, or Visual Basic.
Rectangle Control
Text Box Control
The Microsoft Access database engine recognizes several overlapping sets of data types. In Microsoft Access, there are four different contexts in which you may need to specify a data type  in table Design view , in the Query Parameters dialog box, in Visual Basic, and in SQL view in a query.
The Microsoft Access database engine recognizes several overlapping sets of data types.
The following table compares the five sets of data types that correspond to each context. The first column lists the Type property settings available in table Design view and the five FieldSize property settings for the Number data type. The second column lists the corresponding query parameter data types available for designing parameter queries in the Query Parameters dialog box. The third column lists the corresponding Visual Basic data types. The fourth column lists DAO Field object data types. The fifth column lists the corresponding Jet database engine SQL data types defined by the Access database engine along with their valid synonyms.
The OptionValue property is set to a number because the value of an option group can only be a number, not text. Microsoft Access stores this number in the underlying table. In the preceding example, if you want to display the name of the shipper instead of a number in the Orders table, you can create a separate table called Shippers that stores shipper names, and then make the ShipVia field in the Orders table a Lookup field that looks up data in the Shippers table.
The OptionValue property is set to a number because the value of an option group can only be a number, not text.
In the preceding example, if you want to display the name of the shipper instead of a number in the Orders table, you can create a separate table called Shippers that stores shipper names, and then make the ShipVia field in the Orders table a Lookup field that looks up data in the Shippers table.
Page Break Control
The page break control marks the start of a new screen or printed page on a form or report.
In a form, a page break is active only when you set the form's DefaultView property to Single Form. Page breaks don't affect a form's datasheet .
In a form, a page break is active only when you set the form's DefaultView property to Single Form.
Page breaks don't affect a form's datasheet .
In Form view , press the PAGE UP or PAGE DOWN key to move to the previous or next page break.
Position page breaks above or below other controls. Placing a page break on the same line as another control splits that control's data.
Page
A Page object corresponds to an individual page on a tab control.
Each Page object can contain one or more controls , such as text boxes or option buttons . Controls on a Page object belong to that Page object's Controls collection. In order to work with a control on a Page object, you must refer to that control within the Page object's Control collection.
Each Page object can contain one or more controls , such as text boxes or option buttons .
Controls on a Page object belong to that Page object's Controls collection.
In order to work with a control on a Page object, you must refer to that control within the Page object's Control collection.
With the tab control, you can construct a single form or dialog box that contains several different tabs, and you can group similar options or data on each tab's page. For example, you might use a tab control on an Employees form to separate general and personal information.
With the tab control, you can construct a single form or dialog box that contains several different tabs, and you can group similar options or data on each tab's page.
For example, you might use a tab control on an Employees form to separate general and personal information.
Parameter Query
A parameter query, which is a type of select query, extends the flexibility of another query by prompting you to enter certain criteria each time the query is run. A parameter query is not, strictly speaking, a separate kind of query; rather, it extends the flexibility of other queries.
A parameter query, which is a type of select query, extends the flexibility of another query by prompting you to enter certain criteria each time the query is run.
A parameter query is not, strictly speaking, a separate kind of query; rather, it extends the flexibility of other queries.
Office PivotTable Control
The Office PivotTable control can add a pivot list to a data access page .
Office Pivot List control
Record Navigation Control
The record navigation control can add record navigation to a data access page .
Record Navigation control
The record navigation control can contain buttons for the following:
First record
Previous record
Next record
Last record
New record
Save record
Undo
Sort ascending
Sort descending
Filter by selection
Toggle filter
Rectangle Control (Data Access Pages)
The rectangle control displays a rectangle on a data access page .
Rectangle
Rectangle control
You can move a rectangle and the controls in it as a single unit by dragging the mouse pointer diagonally across the entire rectangle to select all of the controls. The entire selection can then be moved to a new position.
You can move a rectangle and the controls in it as a single unit by dragging the mouse pointer diagonally across the entire rectangle to select all of the controls.
The entire selection can then be moved to a new position.
Rectangle Control (Forms and Reports)
The rectangle control displays a rectangle on a form or report.
This control should not be confused with the Dynamic HTML rectangle control used on a data access page. For information about a rectangle control on a data access page, see Rectangle Control (Data Access Page).
This control should not be confused with the Dynamic HTML rectangle control used on a data access page.
For information about a rectangle control on a data access page, see Rectangle Control (Data Access Page).
Scrolling Text Control
The scrolling text control can add animated text to a data access page .
Scroll Text control
You use a scrolling text control, often called a marquee , on a data access page to display moving text or text that scrolls. Scrolling text draws attention to a line of text, such as a headline or an important announcement. You display text that is contained in a field of your database by binding the scrolling text control to the field. You can customize scrolling text by setting options such as direction of travel, speed, and type of motion.
You use a scrolling text control, often called a marquee , on a data access page to display moving text or text that scrolls.
Scrolling text draws attention to a line of text, such as a headline or an important announcement.
You display text that is contained in a field of your database by binding the scrolling text control to the field.
You can customize scrolling text by setting options such as direction of travel, speed, and type of motion.
Some Web browsers cannot display scrolling text. In these cases, a normal line of text will be displayed in the control.
Some Web browsers cannot display scrolling text.
In these cases, a normal line of text will be displayed in the control.
Select Query
A select query asks questions about the data stored in your database and returns the result of the query without changing the data. Once the result set is displayed, you can view and, in some cases, change the data in the underlying tables. In contrast, an action query does make changes to your data.
A select query asks questions about the data stored in your database and returns the result of the query without changing the data.
Once the result set is displayed, you can view and, in some cases, change the data in the underlying tables.
In contrast, an action query does make changes to your data.
SQL Specific Query
An SQL specific query is one that can be created only by writing an SQL statement in SQL view. Union, pass-through, and data definition queries are SQL specific queries.
An SQL specific query is one that can be created only by writing an SQL statement in SQL view.
Union, pass-through, and data definition queries are SQL specific queries.
SQL specific query type
Union
An SQL specific select query that combines corresponding fields from two or more tables or queries into one field. For example, a union query of the Customers table and the Suppliers table results in a snapshot that contains all the specified records from both the Customers table and the Suppliers table.
An SQL specific select query that combines corresponding fields from two or more tables or queries into one field.
For example, a union query of the Customers table and the Suppliers table results in a snapshot that contains all the specified records from both the Customers table and the Suppliers table.
Pass-Through
An SQL specific query that sends commands directly to an SQL database server (such as Microsoft SQL Server). With pass-through queries, you work with the tables on the server instead of linking the tables to your Microsoft Access database.
An SQL specific query that sends commands directly to an SQL database server (such as Microsoft SQL Server).
With pass-through queries, you work with the tables on the server instead of linking the tables to your Microsoft Access database.
Data Definition
An SQL specific query that can create or delete an index, or create, alter, or delete a table.
Tab Control
A tab control contains multiple pages on which you can place other controls, such as text boxes or option buttons . When a user clicks the corresponding tab, that page becomes active.
A tab control contains multiple pages on which you can place other controls, such as text boxes or option buttons .
When a user clicks the corresponding tab, that page becomes active.
Text Box Control (Data Access Pages)
Text boxes on a data access page display data from a record source . This type of text box is called a bound text box because it's bound to data in a field. Text boxes can also be unbound . For example, you can create an unbound text box to display the results of a calculation, or to accept input from a user. Data in an unbound text box isn't saved with the database.
Text boxes on a data access page display data from a record source .
This type of text box is called a bound text box because it's bound to data in a field.
This control should not be confused with the Dynamic HTML text box control used on a data access page. For information about a text box control on a data access page, see Text Box Control (Data Access Pages).
Text boxes can also be unbound .
For example, you can create an unbound text box to display the results of a calculation, or to accept input from a user.
Data in an unbound text box isn't saved with the database.
Text box
Text Box control
Text Box Control (Forms and Reports)
Text boxes on a form or report display data from a record source . This type of text box is called a bound text box because it's bound to data in a field. Text boxes can also be unbound . For example, you can create an unbound text box to display the results of a calculation, or to accept input from a user. Data in an unbound text box isn't saved with the database.
Text boxes on a form or report display data from a record source .
This control should not be confused with the Dynamic HTML text box control used on a data access page.
For information about a text box control on a data access page, see Text Box Control (Data Access Pages).
Toggle Button Control
A toggle button on a form is a stand-alone control used to display a Yes/No value from an underlying record source .
When you click a toggle button that's bound to a Yes/No field, Microsoft Access displays the value in the underlying table according to the field's Format property (Yes/No, True / False , or On/Off).
Toggle buttons are most useful when used in an option group with other buttons.
You can also use a toggle button in a custom dialog box to accept user input.
Unbound Object Frame Control
The unbound object frame control displays a picture, chart , or any OLE object not stored in a table. For example, you can use an unbound object frame to display a chart that you created and stored in Microsoft Graph.
The unbound object frame control displays a picture, chart , or any OLE object not stored in a table.
For example, you can use an unbound object frame to display a chart that you created and stored in Microsoft Graph.
This control allows you to create or edit the object from within a Microsoft Access form or report by using the application in which the object was originally created.
To display objects that are stored in a Microsoft Access database, use a bound object frame control .
The object in an unbound object frame is the same for every record.
The unbound object frame can display linked or embedded objects.
You can use the unbound object frame or an image control to display unbound pictures in a form or report. The advantage of using the unbound object frame is that you can edit the object directly from the form or report. The advantage of using the image control is that it's faster to display.
Comparison of Data Types
The Microsoft Jet database engine recognizes several overlapping sets of data types. In Microsoft Access, there are four different contexts in which you may need to specify a data type  in table Design view , in the Query Parameters dialog box, in Visual Basic, and in SQL view in a query.
The Microsoft Jet database engine recognizes several overlapping sets of data types.
In Microsoft Access, there are four different contexts in which you may need to specify a data type  in table Design view , in the Query Parameters dialog box, in Visual Basic, and in SQL view in a query.
The following table compares the five sets of data types that correspond to each context. The first column lists the Type property settings available in table Design view and the five FieldSize property settings for the Number data type. The second column lists the corresponding query parameter data types available for designing parameter queries in the Query Parameters dialog box. The third column lists the corresponding Visual Basic data types. The fourth column lists DAO Field object data types. The fifth column lists the corresponding Jet database engine SQL data types defined by the Jet database engine along with their valid synonyms.
The following table compares the five sets of data types that correspond to each context.
The first column lists the Type property settings available in table Design view and the five FieldSize property settings for the Number data type.
The second column lists the corresponding query parameter data types available for designing parameter queries in the Query Parameters dialog box.
The third column lists the corresponding Visual Basic data types.
The fourth column lists DAO Field object data types.
The fifth column lists the corresponding Jet database engine SQL data types defined by the Jet database engine along with their valid synonyms.
Table fields
Query parameters
ADO Data Type property constants
Microsoft Jet database engine SQL and synonyms
Not supported
Binary
BINARY (See Notes) (Synonym: VARBINARY)
Yes/No
BOOLEAN (Synonyms: BIT, LOGICAL, LOGICAL1, YESNO)
Number ( FieldSize = Byte)
Byte
BYTE (Synonym: INTEGER1)
AutoNumber ( FieldSize =
Long Integer)
Long Integer
COUNTER (Synonym: AUTOINCREMENT)
Currency
CURRENCY (Synonym: MONEY)
Date/Time
DATETIME (Synonyms: DATE, TIME, TIMESTAMP)
Number ( FieldSize = Double)
Double
DOUBLE (Synonyms: FLOAT, FLOAT8, IEEEDOUBLE, NUMBER, NUMERIC)
AutoNumber /GUID
( FieldSize = Replication ID)
Replication ID
GUID
Number ( FieldSize = Long Integer)
LONG (See Notes) (Synonyms: INT, INTEGER, INTEGER4)
OLE Object
String
The information that you want to add to the module.
LONGBINARY (Synonyms: GENERAL, OLEOBJECT)
Memo
LONGTEXT (Synonyms: LONGCHAR, MEMO, NOTE)
Number ( FieldSize = Single)
Single
SINGLE (Synonyms: FLOAT4, IEEESINGLE, REAL)
Number ( FieldSize = Integer)
Integer
SHORT (See Notes) (Synonyms: INTEGER2, SMALLINT)
Text
TEXT (Synonyms: ALPHANUMERIC, CHAR, CHARACTER, STRING, VARCHAR)
Hyperlink
Value
VALUE (See Notes)
Microsoft Access itself doesn't use the BINARY data type. It's recognized only for use in queries on linked tables from other database products that support the BINARY data type.
Microsoft Access itself doesn't use the BINARY data type.
It's recognized only for use in queries on linked tables from other database products that support the BINARY data type.
The INTEGER data type in Jet database engine SQL doesn't correspond to the Integer data type for table fields, query parameters, or Visual Basic. Instead, in SQL, the INTEGER data type corresponds to a Long Integer data type for table fields and query parameters and to a Long data type in Visual Basic.
The INTEGER data type in Jet database engine SQL doesn't correspond to the Integer data type for table fields, query parameters, or Visual Basic.
Instead, in SQL, the INTEGER data type corresponds to a Long Integer data type for table fields and query parameters and to a Long data type in Visual Basic.
The VALUE reserved word doesn't represent a data type defined by the Jet database engine. However, in Microsoft Access or SQL queries, the VALUE reserved word can be considered a valid synonym for the Visual Basic Variant data type.
The VALUE reserved word doesn't represent a data type defined by the Jet database engine.
However, in Microsoft Access or SQL queries, the VALUE reserved word can be considered a valid synonym for the Visual Basic Variant data type.
If you are setting the data type for a DAO object in Visual Basic code, you must set the object's Type property.
Activate Event
The Activate event occurs when a form or report receives the focus and becomes the active window.
Private Sub object _Activate()
Object The name of a Form or Report.
The Activate event doesn't occur when a form receives focus back from a dialog box, popup, or another form.
To run a macro or event procedure when these events occur, set the OnActivate , or OnDeactivate property to the name of the macro or to [Event Procedure].
You can make a form or report active by opening it, clicking it or a control on it, or by using the SetFocus method in Visual Basic (for forms only).
The Activate event can occur only when a form or report is visible.
The Activate event occurs before the GotFocus event; the Deactivate event occurs after the LostFocus event.
When you switch between two open forms, the Deactivate event occurs for the form being switched from, and the Activate event occurs for the form being switched to. If the forms contain no visible, enabled controls, the LostFocus event occurs for the first form before the Deactivate event, and the GotFocus event occurs for the second form after the Activate event.
When you switch between two open forms, the Deactivate event occurs for the form being switched from, and the Activate event occurs for the form being switched to.
If the forms contain no visible, enabled controls, the LostFocus event occurs for the first form before the Deactivate event, and the GotFocus event occurs for the second form after the Activate event.
When you first open a form, the following events occur in this order:
When you close a form, the following events occur in this order:
If you're trying to decide whether to use the Open or Load event for your macro or event procedure, one significant difference is that the Open event can be canceled, but the Load event can't. For example, if you're dynamically building a record source for a form in an event procedure for the form's Open event, you can cancel opening the form if there are no records to display. Similarly, the Unload event can be canceled, but the Close event can't.
If you're trying to decide whether to use the Open or Load event for your macro or event procedure, one significant difference is that the Open event can be canceled, but the Load event can't.
Similarly, the Unload event can be canceled, but the Close event can't.
The Unload event occurs before the Close event. The Unload event can be canceled, but the Close event can't.
You can use the ShowToolbar action in an Activate or Deactivate macro to display or hide a custom toolbar. Use the Activate or Deactivate event to display or hide custom toolbars when you have more than one form loaded at a time. If you have only one form loaded at a time, you can use the Open and Close events.
You can use the ShowToolbar action in an Activate or Deactivate macro to display or hide a custom toolbar.
Use the Activate or Deactivate event to display or hide custom toolbars when you have more than one form loaded at a time.
If you have only one form loaded at a time, you can use the Open and Close events.
If you use a Deactivate macro to hide a custom toolbar on a form, also make sure to hide the toolbar in response to the Unload event for the form, because the Deactivate event doesn't occur when a form is unloaded. Don't use the GotFocus or LostFocus event to display or hide a custom toolbar on a form, because these events aren't triggered on forms that contain enabled controls.
If you use a Deactivate macro to hide a custom toolbar on a form, also make sure to hide the toolbar in response to the Unload event for the form, because the Deactivate event doesn't occur when a form is unloaded.
Don't use the GotFocus or LostFocus event to display or hide a custom toolbar on a form, because these events aren't triggered on forms that contain enabled controls.
You can't use the CancelEvent action in an Activate or Deactivate macro.
Example
The following example shows how to display a custom toolbar named CustomToolbar when a form receives the focus and to hide it when the focus moves to a different window.
' Display custom toolbar.
' Hide custom toolbar. DoCmd.ShowToolbar CustomToolbar, acToolbarNo
' Hide custom toolbar.
AfterDelConfirm Event
The AfterDelConfirm event occurs after the user confirms the deletions and the records are actually deleted or when the deletions are canceled.
Status Indicates whether a record has been deleted. The Status argument can be any of the following intrinsic constants:
Status Indicates whether a record has been deleted.
The Status argument can be any of the following intrinsic constants:
Constant Description
acDeleteOK Indicates the deletion was successful.
acDeleteCancel Indicates the deletion was canceled in Visual Basic.
acDeleteUserCancel Indicates the deletion was canceled by the user.
To run a macro or event procedure when these events occur, set the AfterDelConfirm property to the name of the macro or to [Event Procedure].
After a record is deleted, it's stored in a temporary buffer.
The AfterDelConfirm event occurs after a record or records are actually deleted or after a deletion or deletions are canceled. If the BeforeDelConfirm event isn't canceled, the AfterDelConfirm event occurs after the Delete Confirm dialog box is displayed. The AfterDelConfirm event occurs even if the BeforeDelConfirm event is canceled. The AfterDelConfirm event procedure returns status information about the deletion. For example, you can use a macro or event procedure associated with the AfterDelConfirm event to recalculate totals affected by the deletion of records.
The AfterDelConfirm event occurs after a record or records are actually deleted or after a deletion or deletions are canceled.
If you cancel the Delete event, the BeforeDelConfirm and AfterDelConfirm events don't occur and the Delete Confirm dialog box isn't displayed.
The BeforeDelConfirm and AfterDelConfirm events don't occur and the Delete Confirm dialog box isn't displayed if you clear the Record Changes check box under Confirm on the Edit/Find tab of the Options dialog box, available by clicking Options on the Tools menu.
You can delete one or more records at a time. The Delete event occurs after each record is deleted. This enables you to access the data in each record before it's actually deleted, and selectively confirm or cancel each deletion in the Delete macro or event procedure. When you delete more than one record, the Current event for the record following the last deleted record and the Enter and GotFocus events for the first control in this record don't occur until all the records are deleted. In other words, a Delete event occurs for each selected record, but no other events occur until all the selected records are deleted. The BeforeDelConfirm and AfterDelConfirm events also don't occur until all the selected records are deleted.
The BeforeDelConfirm and AfterDelConfirm events also don't occur until all the selected records are deleted.
The following example shows how you can prevent a user from deleting records from a table.
If you cancel the Delete event, the BeforeDelConfirm event does not occur and the Delete Confirm dialog box isn't displayed.
If the BeforeDelConfirm event isn't canceled, the AfterDelConfirm event occurs after the Delete Confirm dialog box is displayed.
To try this example, add the following event procedure to a form that is based on a table. Switch to form Datasheet view and try to delete a record.
To try this example, add the following event procedure to a form that is based on a table.
The BeforeDelConfirm event does not occur and the Delete Confirm dialog box isn't displayed if you clear the Record Changes check box under Confirm on the Edit/Find tab of the Options dialog box, available by clicking Options on the Tools menu.
The AfterDelConfirm event occurs even if the BeforeDelConfirm event is canceled.
The AfterDelConfirm event procedure returns status information about the deletion.
For example, you can use a macro or event procedure associated with the AfterDelConfirm event to recalculate totals affected by the deletion of records.
If you cancel the Delete event, the AfterDelConfirm event does not occur and the Delete Confirm dialog box isn't displayed.
The AfterDelConfirm event does not occur and the Delete Confirm dialog box isn't displayed if you clear the Record Changes check box under Confirm on the Edit/Find tab of the Options dialog box, available by clicking Options on the Tools menu.
By running a macro or an event procedure when the Delete event occurs, you can prevent a record from being deleted or allow a record to be deleted only under certain conditions. You can also use a Delete event to display a dialog box asking whether the user wants to delete a record before it's deleted.
By running a macro or an event procedure when the Delete event occurs, you can prevent a record from being deleted or allow a record to be deleted only under certain conditions.
You can also use a Delete event to display a dialog box asking whether the user wants to delete a record before it's deleted.
To delete a record, you can click Delete Record on the Edit menu. This deletes the current record (the record indicated by the record selector ). You can also click the record selector or click Select Record on the Edit menu to select the record, and then press the DEL key to delete it. If you click Delete Record , the record selector of the current record, or Select Record , the Exit and LostFocus events for the control that has the focus occur. If you've changed any data in the record, the BeforeUpdate and AfterUpdate events for the record occur before the Exit and LostFocus events. If you click the record selector of a different record, the Current event for that record also occurs.
To delete a record, you can click Delete Record on the Edit menu.
This deletes the current record (the record indicated by the record selector ).
You can also click the record selector or click Select Record on the Edit menu to select the record, and then press the DEL key to delete it.
If you click Delete Record , the record selector of the current record, or Select Record , the Exit and LostFocus events for the control that has the focus occur.
If you've changed any data in the record, the BeforeUpdate and AfterUpdate events for the record occur before the Exit and LostFocus events.
If you click the record selector of a different record, the Current event for that record also occurs.
After you delete the record, the focus moves to the next record following the deleted record, and the Current event for that record occurs, followed by the Enter and GotFocus events for the first control in that record.
The BeforeDelConfirm event then occurs, just before Microsoft Access displays the Delete Confirm dialog box asking you to confirm the deletion. After you respond to the dialog box by confirming or canceling the deletion, the AfterDelConfirm event occurs.
The BeforeDelConfirm event then occurs, just before Microsoft Access displays the Delete Confirm dialog box asking you to confirm the deletion.
After you respond to the dialog box by confirming or canceling the deletion, the AfterDelConfirm event occurs.
After you respond to the dialog box by confirming or canceling the deletion, the AfterDelConfirm event occurs.
You can delete one or more records at a time. The Delete event occurs after each record is deleted. This enables you to access the data in each record before it's actually deleted, and selectively confirm or cancel each deletion in the Delete macro or event procedure. When you delete more than one record, the Current event for the record following the last deleted record and the Enter and GotFocus events for the first control in this record don't occur until all the records are deleted. In other words, a Delete event occurs for each selected record, but no other events occur until all the selected records are deleted. The AfterDelConfirm event also does not occur until all the selected records are deleted.
You can delete one or more records at a time.
The Delete event occurs after each record is deleted.
This enables you to access the data in each record before it's actually deleted, and selectively confirm or cancel each deletion in the Delete macro or event procedure.
When you delete more than one record, the Current event for the record following the last deleted record and the Enter and GotFocus events for the first control in this record don't occur until all the records are deleted.
In other words, a Delete event occurs for each selected record, but no other events occur until all the selected records are deleted.
The AfterDelConfirm event also does not occur until all the selected records are deleted.
You can use a Delete macro to display the Delete Confirm dialog box asking whether the user wants to delete a record before it's deleted.
You can use a BeforeDelConfirm or AfterDelConfirm macro to respond whenever the user deletes a record. However, the BeforeDelConfirm and AfterDelConfirm macros can't set the argument determining whether the Delete Confirm dialog box is displayed and can't return the argument indicating the status of the deletion, so you typically use event procedures with these events.
You can use the CancelEvent action in a Delete macro to cancel the deletion.
You can use the CancelEvent action in a BeforeDelConfirm macro to cancel the deletion of all the deleted records. If you do this, the Delete Confirm dialog box isn't displayed. However, the AfterDelConfirm event occurs even if you cancel the BeforeDelConfirm event.
You can use the CancelEvent action in a BeforeDelConfirm macro to cancel the deletion of all the deleted records.
If you do this, the Delete Confirm dialog box isn't displayed.
However, the AfterDelConfirm event occurs even if you cancel the BeforeDelConfirm event.
You can't use the CancelEvent action in an AfterDelConfirm macro.
The following example shows how you can use the BeforeDelConfirm event procedure to suppress the Delete Confirm dialog box and display a custom dialog box when a record is deleted. It also shows how you can use the AfterDelConfirm event procedure to display a message indicating whether the deletion progressed in the usual way or whether it was canceled in Visual Basic or by the user.
The following example shows how you can use the BeforeDelConfirm event procedure to suppress the Delete Confirm dialog box and display a custom dialog box when a record is deleted.
It also shows how you can use the AfterDelConfirm event procedure to display a message indicating whether the deletion progressed in the usual way or whether it was canceled in Visual Basic or by the user.
AfterFinalRender Event
Occurs after all elements in the specified PivotChart view have been rendered.
drawObject A ChChartDraw object. Use the methods and properties of this object to draw objects on the chart.
drawObject A ChChartDraw object.
Use the methods and properties of this object to draw objects on the chart.
The following example demonstrates the syntax for a subroutine that traps the AfterFinalRender event.
AfterInsert Event
The AfterInsert event occurs after a new record is added.
Setting the value of a control by using a macro or Visual Basic doesn't trigger these events.
You can use an AfterInsert event procedure or macro to requery a recordset whenever a new record is added.
To run a macro or event procedure when the AfterInsert event occurs, set the OnAfterInsert property to the name of the macro or to [Event Procedure].
You can use these macros to display messages or useful information. For example, you can have the BeforeInsert macro display data the user needs when entering a new record.
You can use these macros to display messages or useful information.
For example, you can have the BeforeInsert macro display data the user needs when entering a new record.
You can use the CancelEvent action in a BeforeInsert macro to cancel the creation of the new record. When you use the CancelEvent action in a BeforeInsert macro, the focus returns to the new record, which is blank (the character that the user typed is deleted).
BeforeQuery Event
You can use the CancelEvent action in a BeforeInsert macro to cancel the creation of the new record.
When you use the CancelEvent action in a BeforeInsert macro, the focus returns to the new record, which is blank (the character that the user typed is deleted).
Occurs when the specified PivotTable view queries its data source.
Private Sub Form_BeforeQuery ()
This event occurs quite frequently. Some examples of actions that trigger this event include adding fields to the PivotTable view, moving fields, sorting, or filtering data.
This event occurs quite frequently.
You can't use the CancelEvent action in an AfterInsert macro.
This example shows how you can use a BeforeInsert event procedure to verify that the user wants to create a new record, and an AfterInsert event procedure to requery the record source for the Employees form after a record has been added.
To try the example, add the following event procedure to a form named Employees that is based on a table or query. Switch to form Datasheet view and try to insert a record.
To try the example, add the following event procedure to a form named Employees that is based on a table or query.
Switch to form Datasheet view and try to insert a record.
AfterLayout Event
Occurs after all charts in the specfied PivotChart view have been laid out, but before they have been rendered.
During this event, you can reposition the ChTitle , ChLegend , ChChart , and ChAxis objects of each PivotChart view by changing their Left and Top properties. You can reposition the ChPlotArea object by changing its Left , Top , Right , and Bottom properties. These properties cannot be changed outside of this event.
During this event, you can reposition the ChTitle , ChLegend , ChChart , and ChAxis objects of each PivotChart view by changing their Left and Top properties.
You can reposition the ChPlotArea object by changing its Left , Top , Right , and Bottom properties.
These properties cannot be changed outside of this event.
The following example demonstrates the syntax for a subroutine that traps the AfterLayout event.
AfterRender Event
Occurs after the object represented by the chartObject argument has been rendered.
chartObject The object that has just been rendered. Use the TypeName function to determine what type of object has just been rendered.
chartObject The object that has just been rendered.
Use the TypeName function to determine what type of object has just been rendered.
The following example demonstrates the syntax for a subroutine that traps the AfterRender event.
Returns or sets which macro, event procedure, or user-defined function runs when the AfterUpdate event occurs. Read/write String .
AfterUpdate Event
The AfterUpdate event occurs after changed data in a control or record is updated.
Private Sub object_AfterUpdate()
Object The name of a form or a control.
Changing data in a control by using Visual Basic or a macro containing the SetValue action doesn't trigger these events for the control. However, if you then move to another record or save the record, the form's AfterUpdate event does occur.
Changing data in a control by using Visual Basic or a macro containing the SetValue action doesn't trigger these events for the control.
However, if you then move to another record or save the record, the form's AfterUpdate event does occur.
The AfterUpdate event applies only to controls on a form, not controls on a report .
This event does not apply to option buttons , check boxes , or toggle buttons in an option group . It applies only to the option group itself.
In the following example, the Click event procedure is attached to the ReadOnly check box. The event procedure sets the Enabled and Locked properties of another control on the form, the Amount text box. When the check box is clicked, the event procedure checks whether the check box is being selected or cleared and then sets the text box's properties to enable or disable editing accordingly.
In the following example, the Click event procedure is attached to the ReadOnly check box.
The Activate event occurs before the GotFocus event; the Deactivate event occurs after the LostFocus event.
Occurs when a filter is applied to a form.
. ApplyFilter ( Cancel , ApplyType )
The setting determines if the ApplyFilter event occurs. Setting the Cancel argument to True cancels the ApplyFilter event and the filter is not applied to the form.
A variable that represents a ComboBox object.
The Change event occurs when the contents of the specified control changes.
The BeforeUpdate and AfterUpdate events for the text box or combo box control occur after you have entered the new or changed data in the control and moved to another control (or clicked Save Record on the Records menu), and therefore after all of the Change events for the control.
In combo boxes for which the LimitToList property is set to Yes, the NotInList event occurs after you enter a value that isn't in the list and attempt to move to another control or save the record. It occurs after all the Change events for the combo box. In this case, the BeforeUpdate and AfterUpdate events for the combo box don't occur, because Microsoft Access doesn't accept a value that is not in the list.
To run a macro or event procedure when this event occurs, set the AfterUpdate property to the name of the macro or to [Event Procedure].
The AfterUpdate event is triggered when a control or record is updated. Within a record, changed data in each control is updated when the control loses the focus or when the user presses ENTER or TAB. When the focus leaves the record or if the user clicks Save Record on the Records menu, the entire record is updated, and the data is saved in the database.
The AfterUpdate event is triggered when a control or record is updated.
Within a record, changed data in each control is updated when the control loses the focus or when the user presses ENTER or TAB.
AfterUpdate macros and event procedures run only if you change the data in a control. This event does not occur when a value changes in a calculated control . AfterUpdate macros and event procedures for a form run only if you change the data in one or more controls in the record.
AttachmentCurrent Event
Occurs when the focus moves to or from a file contained in the specified Attachment control, making it the current attachment, or when the form is refreshed or requeried.
A variable that represents an Attachment object.
By running a macro or event procedure when the AttachmentCurrent event occurs, you can display a message or synchronize controls in the form related to the current attachment.
The BeforeUpdate event occurs before changed data in a control or record is updated.
When the focus leaves the record or if the user clicks Save Record on the Records menu, the entire record is updated, and the data is saved in the database.
When you enter new or changed data in a control on a form and then move to another record or save the record by clicking Save Record on the Records menu, the AfterUpdate event for the form occur immediately after the AfterUpdate event for the control. When you move to a different record, the Exit and LostFocus events for the control occur, followed by the Current event for the record you moved to, and the Enter and GotFocus events for the first control in this record. To run the AfterUpdate macro or event procedure without running the Exit and LostFocus macros or event procedures, save the record by using the Save Record command on the Records menu.
When you enter new or changed data in a control on a form and then move to another record or save the record by clicking Save Record on the Records menu, the AfterUpdate event for the form occur immediately after the AfterUpdate event for the control.
When you move to a different record, the Exit and LostFocus events for the control occur, followed by the Current event for the record you moved to, and the Enter and GotFocus events for the first control in this record.
To run the AfterUpdate macro or event procedure without running the Exit and LostFocus macros or event procedures, save the record by using the Save Record command on the Records menu.
AfterUpdate macros and event procedures run only if you change the data in a control. This event does not occur when a value changes in a calculated control . AfterUpdate macros and event procedures for a form run only if you change the data in one or more controls in the record.
For bound controls , the OldValue property isn't set to the updated value until after the AfterUpdate event for the form occurs. Even if the user enters a new value in the control, the OldValue property setting isn't changed until the data is saved (the record is updated). If you cancel an update, the value of the OldValue property replaces the existing value in the control.
For bound controls , the OldValue property isn't set to the updated value until after the AfterUpdate event for the form occurs.
Even if the user enters a new value in the control, the OldValue property setting isn't changed until the data is saved (the record is updated).
If you cancel an update, the value of the OldValue property replaces the existing value in the control.
You often use the BeforeUpdate event to validate data, especially when you perform complex validations, such as those that:
Contain references to controls on other forms or contain user-defined functions.
On a form , the DblClick event occurs when the user double-clicks a blank area or record selector on the form. For a control, it occurs when the user double-clicks a control or its label in Form view . The DblClick event occurs when the user double-clicks the form or control but before the result of the double-click action occurs (for example, before Microsoft Access selects the word that the insertion point is on in a text box ).
The following example shows how you can use a DblClick event procedure to open a form that displays records from the table that is the row source of a combo box. When the user double-clicks the Salesperson combo box in an Orders form, the Employees form is displayed, showing the record for the employee selected in the combo box.
The following example shows how you can use a DblClick event procedure to open a form that displays records from the table that is the row source of a combo box.
A run-time error will occur if you attempt to modify the data contained in the control that fired the BeforeUpdate event in the event's procedure.
To perform simple validations, or more complex validations such as requiring a value in a field or validating more than one control on a form, you can use the ValidationRule property for controls and the ValidationRule and Required properties for fields and records in tables.
You can use BeforeUpdate macros if you want to store all the validations for a form in one macro group or if you use a validation expression on several forms.
For example, suppose you have a form on which the user enters the name of a country in a Country control and its corresponding postal code in a Postal Code control. You use conditional expressions in the macro to make sure that the data entered in the Country control corresponds to the data entered in the Postal Code control and to display a message if invalid data is entered in the Postal Code control.
For example, suppose you have a form on which the user enters the name of a country in a Country control and its corresponding postal code in a Postal Code control.
You use conditional expressions in the macro to make sure that the data entered in the Country control corresponds to the data entered in the Postal Code control and to display a message if invalid data is entered in the Postal Code control.
You can use an AfterUpdate macro to display a different page in the form or move the focus to a particular control or record. For example, when the user enters a value in a Category control on a form, you can use the GoToPage action in an AfterUpdate macro to move the focus to the page of the form that contains the controls for that category.
You can use an AfterUpdate macro to display a different page in the form or move the focus to a particular control or record.
For example, when the user enters a value in a Category control on a form, you can use the GoToPage action in an AfterUpdate macro to move the focus to the page of the form that contains the controls for that category.
You can use the CancelEvent action in a BeforeUpdate macro to cancel the update. If the BeforeUpdate macro is attached to a control, the CancelEvent action returns the focus to the control, and the data the user entered remains in the control.
You can use the CancelEvent action in a BeforeUpdate macro to cancel the update.
If the BeforeUpdate macro is attached to a control, the CancelEvent action returns the focus to the control, and the data the user entered remains in the control.
If a BeforeUpdate macro is attached to a form (in which it runs each time a record is changed), the CancelEvent action returns the focus to the record.
You can't use the CancelEvent action in an AfterUpdate macro to cancel the AfterUpdate event.
ApplyFilter Event
The ApplyFilter event can occur within a Microsoft Access project (.adp) or Access database (.mdb).
Within an Access database, an ApplyFilter event occurs when the user does one of the following:
Clicks Apply Filter/Sort on the Records menu in Form view , clicks Apply Filter/Sort on the Filter menu in the Filter window, or clicks Apply Filter on the toolbar . This applies the most recently created filter (created by using either the Filter By Form feature or the Advanced Filter/Sort window).
Clicks Apply Filter/Sort on the Records menu in Form view , clicks Apply Filter/Sort on the Filter menu in the Filter window, or clicks Apply Filter on the toolbar .
This applies the most recently created filter (created by using either the Filter By Form feature or the Advanced Filter/Sort window).
On the Records menu in Form view, points to Filter and clicks Filter By Selection , or clicks Filter By Selection on the toolbar. This applies a filter based on the current selection in the form .
On the Records menu in Form view, points to Filter and clicks Filter By Selection , or clicks Filter By Selection on the toolbar.
This applies a filter based on the current selection in the form .
On the Records menu in Form view, points to Filter and clicks Filter Excluding Selection . This applies a filter excluding the current selection in the form.
On the Records menu in Form view, points to Filter and clicks Filter Excluding Selection .
This applies a filter excluding the current selection in the form.
Clicks Remove Filter/Sort on the Records menu in Form view, or clicks Remove Filter on the toolbar. This removes any filter (or sort) currently applied to the form.
Clicks Remove Filter/Sort on the Records menu in Form view, or clicks Remove Filter on the toolbar.
This removes any filter (or sort) currently applied to the form.
On subforms, the ApplyFilter event does not occur when the user removes a filter. In this case, the ApplyFilter event occurs on the parent form.
On subforms, the ApplyFilter event does not occur when the user removes a filter.
In this case, the ApplyFilter event occurs on the parent form.
Clicks Filter By Selection , Filter Excluding Selection , or Remove Filter/Sort or enters a value or expression in the Filter For box on the shortcut menu when a bound control has the focus .
Closes the Advanced Filter/Sort window or the Filter By Form window.
Clicks Advanced Filter/Sort on the Filter menu while the Filter By Form window is open, or clicks Filter By Form on the Filter menu while the Advanced Filter/Sort window is open. This causes the ApplyFilter event to occur when the open filter window is closed, and then the Filter event to occur when the other filter window is opened.
Clicks Advanced Filter/Sort on the Filter menu while the Filter By Form window is open, or clicks Filter By Form on the Filter menu while the Advanced Filter/Sort window is open.
This causes the ApplyFilter event to occur when the open filter window is closed, and then the Filter event to occur when the other filter window is opened.
Within an Access project, an ApplyFilter event occurs when the user does one of the following:
Clicks Apply Filter/Sort on the Records menu in Form view, clicks Apply Filter/Sort on the Filter menu in the Filter window, or clicks Apply Filter on the toolbar. This applies the most recently created filter (created by using the Filter By Form feature).
Clicks Apply Filter/Sort on the Records menu in Form view, clicks Apply Filter/Sort on the Filter menu in the Filter window, or clicks Apply Filter on the toolbar.
This applies the most recently created filter (created by using the Filter By Form feature).
Clicks Apply Server Filter on the Records menu in Form view, clicks Apply Server Filter on the Filter menu in the Filter window, or clicks Apply Server Filter on the toolbar. This applies the most recently created filter (created by using the Server Filter By Form feature).
Clicks Apply Server Filter on the Records menu in Form view, clicks Apply Server Filter on the Filter menu in the Filter window, or clicks Apply Server Filter on the toolbar.
This applies the most recently created filter (created by using the Server Filter By Form feature).
On the Records menu in Form view, points to Filter and clicks Filter By Selection , or clicks Filter By Selection on the toolbar. This applies a filter based on the current selection in the form.
This applies a filter based on the current selection in the form.
Clicks Filter By Selection or Filter Excluding Selection or enters a value or expression in the Filter For box on the shortcut menu when a bound control has the focus.
To run a macro or event procedure when this event occurs, set the OnApplyFilter property to the name of the macro or to [Event Procedure].
You can use the ApplyFilter event to:
Make sure the filter that is being applied is correct. For example, you may want to be sure that any filter applied to an Orders form includes criteria restricting the OrderDate field. To do this, check the form's Filter or ServerFilter property value to make sure this criteria is included in the WHERE clause expression.
Make sure the filter that is being applied is correct.
For example, you may want to be sure that any filter applied to an Orders form includes criteria restricting the OrderDate field.
To do this, check the form's Filter or ServerFilter property value to make sure this criteria is included in the WHERE clause expression.
Change the display of the form before the filter is applied. For example, when you apply a certain filter, you may want to disable or hide some fields that aren't appropriate for the records displayed by this filter.
Change the display of the form before the filter is applied.
For example, when you apply a certain filter, you may want to disable or hide some fields that aren't appropriate for the records displayed by this filter.
Undo or change actions you took when the Filter event occurred. For example, you can disable or hide some controls on the form when the user is creating the filter, because you don't want these controls to be included in the filter criteria. You can then enable or show these controls after the filter is applied.
The actions in the ApplyFilter macro or event procedure occur before the filter is applied or removed; or after the Advanced Filter/Sort, Filter By Form, or Server Filter By Form window is closed, but before the form is redisplayed. The criteria you've entered in the newly created filter are available to the ApplyFilter macro or event procedure as the setting of the Filter or ServerFilter property.
The actions in the ApplyFilter macro or event procedure occur before the filter is applied or removed; or after the Advanced Filter/Sort, Filter By Form, or Server Filter By Form window is closed, but before the form is redisplayed.
The criteria you've entered in the newly created filter are available to the ApplyFilter macro or event procedure as the setting of the Filter or ServerFilter property.
The ApplyFilter event doesn't occur when the user does one of the following:
Applies or removes a filter by using the ApplyFilter , OpenForm , or ShowAllRecords actions in a macro, or their corresponding methods of the DoCmd object in Visual Basic.
Uses the Close action or the Close method of the DoCmd object to close the Advanced Filter/Sort, Filter By Form, or Server Filter By Form window.
Sets the Filter or ServerFilter property or FilterOn or ServerFilterByForm property in a macro or Visual Basic (although you can set these properties in an ApplyFilter macro or event procedure).
The following example shows how to hide the AmountDue, Tax, and TotalDue controls on an Orders form when the applied filter restricts the records to only those orders that have been paid for.
To try this example, add the following event procedure to an Orders form that contains AmountDue, Tax, and TotalDue controls. Run a filter that lists only those orders that have been paid for.
To try this example, add the following event procedure to an Orders form that contains AmountDue, Tax, and TotalDue controls.
Run a filter that lists only those orders that have been paid for.
BeforeDelConfirm Event
The BeforeDelConfirm event occurs after the user deletes to the buffer one or more records, but before Microsoft Access displays a dialog box asking the user to confirm the deletions.
Cancel The setting determines if the BeforeDelConfirm event occurs. Setting the Cancel argument to True cancels the BeforeDelConfirm event and prevents the Delete Confirm dialog box from being displayed. If the event is canceled, the original records are restored, but the AfterDelConfirm event still occurs. If Cancel is set to True, the Response argument is ignored. If Cancel is set to False (0), which it is by default, the value in the Response argument is used by Microsoft Access to determine the type of response to the delete event.
Cancel The setting determines if the BeforeDelConfirm event occurs.
Setting the Cancel argument to True cancels the BeforeDelConfirm event and prevents the Delete Confirm dialog box from being displayed.
If the event is canceled, the original records are restored, but the AfterDelConfirm event still occurs.
If Cancel is set to True, the Response argument is ignored.
If Cancel is set to False (0), which it is by default, the value in the Response argument is used by Microsoft Access to determine the type of response to the delete event.
Response The setting determines whether Microsoft Access displays the Delete Confirm dialog box asking if the record should be deleted. The Response argument can be set to one of the following intrinsic constants:
Response The setting determines whether Microsoft Access displays the Delete Confirm dialog box asking if the record should be deleted.
The Response argument can be set to one of the following intrinsic constants:
acDataErrContinue Continues without displaying the Delete Confirm dialog box. Setting the Cancel argument to False and the Response argument to acDataErrContinue enables Microsoft Access to delete records without prompting the user.
acDataErrContinue Continues without displaying the Delete Confirm dialog box.
Setting the Cancel argument to False and the Response argument to acDataErrContinue enables Microsoft Access to delete records without prompting the user.
acDataErrDisplay (Default) Displays the Delete Confirm dialog box.
To run a macro or event procedure when these events occur, set the BeforeDelConfirm property to the name of the macro or to [Event Procedure].
After a record is deleted, it's stored in a temporary buffer. The BeforeDelConfirm event occurs after the Delete event (or if you've deleted more than one record, after all the records are deleted, with a Delete event occurring for each record), but before the Delete Confirm dialog box is displayed. Canceling the BeforeDelConfirm event restores the record or records from the buffer and prevents the Delete Confirm dialog box from being displayed.
The BeforeDelConfirm event occurs after the Delete event (or if you've deleted more than one record, after all the records are deleted, with a Delete event occurring for each record), but before the Delete Confirm dialog box is displayed.
Canceling the BeforeDelConfirm event restores the record or records from the buffer and prevents the Delete Confirm dialog box from being displayed.
The AfterDelConfirm event occurs after a record or records are actually deleted or after a deletion or deletions are canceled. If the BeforeDelConfirm event isn't canceled, the AfterDelConfirm event occurs after the Delete Confirm dialog box is displayed. The AfterDelConfirm event occurs even if the BeforeDelConfirm event is canceled.
You can delete one or more records at a time. The Delete event occurs after each record is deleted. This enables you to access the data in each record before it's actually deleted, and selectively confirm or cancel each deletion in the Delete macro or event procedure. When you delete more than one record, the Current event for the record following the last deleted record and the Enter and GotFocus events for the first control in this record don't occur until all the records are deleted. In other words, a Delete event occurs for each selected record, but no other events occur until all the selected records are deleted. The BeforeDelConfirm event does not occur until all the selected records are deleted.
The BeforeDelConfirm event does not occur until all the selected records are deleted.
BeforeInsert Event
The BeforeInsert event occurs when the user types the first character in a new record , but before the record is actually created.
Cancel The setting determines if the BeforeInsert event occurs. Setting the Cancel argument to True (1) cancels the BeforeInsert event.
Cancel The setting determines if the BeforeInsert event occurs.
Setting the Cancel argument to True (1) cancels the BeforeInsert event.
To run a macro or event procedure when these events occur, set the BeforeInsert or AfterInsert property to the name of the macro or to [Event Procedure].
The BeforeInsert and AfterInsert events are similar to the BeforeUpdate and AfterUpdate events. These events occur in the following order:
The BeforeInsert and AfterInsert events are similar to the BeforeUpdate and AfterUpdate events.
These events occur in the following order:
If the first character in a new record is typed into a text box or combo box , the BeforeInsert event occurs before the Change event.
The following table summarizes the interaction between these events.
Event
Occurs when
BeforeInsert
User types the first character in a new record.
User updates the record.
Record is updated.
AfterInsert
Record updated is a new record.
If the first character in a new record is typed into a text box or combo box , the BeforeInsert event occurs before the Change event.
Some examples of actions that trigger this event include adding fields to the PivotTable view, moving fields, sorting, or filtering data.
The following example demonstrates the syntax for a subroutine that traps the BeforeQuery event.
A reference to the ChChartDraw object. Use the DrawType property of the returned object to determine what type of rendering is about to occur.
BeforeRender Event
Occurs before any object in the specified PivotChart view has been rendered.
drawObject A reference to the ChChartDraw object. Use the DrawType property of the returned object to determine what type of rendering is about to occur.
drawObject A reference to the ChChartDraw object.
Use the DrawType property of the returned object to determine what type of rendering is about to occur.
chartObject The object that is to be rendered. Use the TypeName function to determine the type of the object.
chartObject The object that is to be rendered.
Use the TypeName function to determine the type of the object.
Cancel Set the Value property of this object to True to cancel the rendering of the PivotChart View object.
The following example demonstrates the syntax for a subroutine that traps the BeforeRender event.
BeforeScreenTip Event
Occurs before a ScreenTip is displayed for an element in a PivotChart view or PivotTable view.
ScreenTipText Set the Value property of this object to the ScreenTip that you want to display. Changing this argument to an empty string effectively hides the ScreenTip.
ScreenTipText Set the Value property of this object to the ScreenTip that you want to display.
Changing this argument to an empty string effectively hides the ScreenTip.
SourceObject The object that generates the ScreenTip.
BeforeUpdate Event
The BeforeUpdate event occurs before changed data in a control or record is updated .
Private Sub object_BeforeUpdate(Cancel As Integer)
Cancel The setting determines if the BeforeUpdate event occurs. Setting the Cancel argument to True (1) cancels the BeforeUpdate event.
Cancel The setting determines if the BeforeUpdate event occurs.
Setting the Cancel argument to True (1) cancels the BeforeUpdate event.
Changing data in a control by using Visual Basic or a macro containing the SetValue action doesn't trigger these events for the control. However, if you then move to another record or save the record, the form's BeforeUpdate event does occur.
However, if you then move to another record or save the record, the form's BeforeUpdate event does occur.
The BeforeUpdate event applies only to controls on a form, not controls on a report .
The BeforeUpdate event does not apply to option buttons , check boxes , or toggle buttons in an option group . It applies only to the option group itself.
To run a macro or event procedure when these events occur, set the BeforeUpdate property to the name of the macro or to [Event Procedure].
The BeforeUpdate event is triggered when a control or record is updated. Within a record, changed data in each control is updated when the control loses the focus or when the user presses ENTER or TAB. When the focus leaves the record or if the user clicks Save Record on the Records menu, the entire record is updated, and the data is saved in the database.
The BeforeUpdate event is triggered when a control or record is updated.
When the focus leaves the record or if the user clicks Save Record on the Records menu, the entire record is updated, and the data is saved in the database.
When you enter new or changed data in a control on a form and then move to another record or save the record by clicking Save Record on the Records menu, the BeforeUpdate event for the form occurs immediately after the BeforeUpdate event for the control. When you move to a different record, the Exit and LostFocus events for the control occur, followed by the Current event for the record you moved to, and the Enter and GotFocus events for the first control in this record. To run the BeforeUpdate macros or event procedures without running the Exit and LostFocus macros or event procedures, save the record by using the Save Record command on the Records menu.
When you enter new or changed data in a control on a form and then move to another record or save the record by clicking Save Record on the Records menu, the BeforeUpdate event for the form occurs immediately after the BeforeUpdate event for the control.
To run the BeforeUpdate macros or event procedures without running the Exit and LostFocus macros or event procedures, save the record by using the Save Record command on the Records menu.
BeforeUpdate macro and event procedures run only if you change the data in a control. These events don't occur when a value changes in a calculated control . BeforeUpdate macro and event procedures for a form run only if you change the data in one or more controls in the record.
For forms, you can use the BeforeUpdate event to cancel updating of a record before moving to another record.
If the user enters a new value in the control, the OldValue property setting isn't changed until the data is saved (the record is updated). If you cancel an update, the value of the OldValue property replaces the existing value in the control.
You often use the BeforeUpdate event to validate data, especially when you perform complex validations, such as those that:
Involve conditions for more than one value on a form.
Display different error messages for different data entered.
Can be overridden by the user.
GotFocus (for the control on the subform that the focus moved to)
If the control you move to on the subform previously had the focus, neither its Enter event nor its GotFocus event occurs, but the Enter event for the subform control does occur.
If you move the focus from a control on a subform to a control on the main form, the Exit and LostFocus events for the control on the subform don't occur, just the Exit event for the subform control and the Enter and GotFocus events for the control on the main form.
Contain references to controls on other forms or contain user-defined functions.
Note To perform simple validations, or more complex validations such as requiring a value in a field or validating more than one control on a form, you can use the ValidationRule property for controls and the ValidationRule and Required properties for fields and records in tables.
A run-time error will occur if you attempt to modify the data contained in the control that fired the BeforeUpdate event in the event's procedure.
The following example shows how you can use a BeforeUpdate event procedure to check whether a product name has already been entered in the database. After the user types a product name in the ProductName box, the value is compared to the ProductName field in the Products table. If there is a matching value in the Products table, a message is displayed that informs the user that the product has already been entered.
The following example shows how you can use a BeforeUpdate event procedure to check whether a product name has already been entered in the database.
After the user types a product name in the ProductName box, the value is compared to the ProductName field in the Products table.
If there is a matching value in the Products table, a message is displayed that informs the user that the product has already been entered.
To try the example, add the following event procedure to a form named Products that contains a text box called ProductName.
Change Event
The Change event occurs when the contents of a text box or the text portion of a combo box changes. It also occurs when you move from one page to another page in a tab control .
The Change event occurs when the contents of a text box or the text portion of a combo box changes.
It also occurs when you move from one page to another page in a tab control .
Private Sub object _Change()
Object The name of a control.
Examples of this event include entering a character directly in the text box or combo box or changing the control's Text property setting by using a macro or Visual Basic.
Setting the value of a control by using a macro or Visual Basic doesn't trigger this event for the control. You must type the data directly into the control, or set the control's Text property.
To run a macro or event procedure when this event occurs, set the OnChange property to the name of the macro or to [Event Procedure].
Setting the value of a control by using a macro or Visual Basic doesn't trigger this event for the control.
You must type the data directly into the control, or set the control's Text property.
This event applies only to controls on a form , not controls on a report .
To run a macro or event procedure when this event occurs, set the OnChange property to the name of the macro or to [Event Procedure].
By running a macro or event procedure when a Change event occurs, you can coordinate data display among controls. You can also display data or a formula in one control and the results in another control.
By running a macro or event procedure when a Change event occurs, you can coordinate data display among controls.
You can also display data or a formula in one control and the results in another control.
The Change event doesn't occur when a value changes in a calculated control.
A Change event can cause a cascading event . This occurs when a macro or event procedure that runs in response to the control's Change event alters the control's contents  for example, by changing a property setting that determines the control's value, such as the Text property for a text box. To prevent a cascading event:
The Click event occurs when the user presses and then releases a mouse button over an object.
The Click event applies only to forms , form sections , and controls on a form, not controls on a report .
To run a macro or event procedure when this event occurs, set the OnClick property to the name of the macro or to [Event Procedure].
Clicks a control with the left mouse button. Clicking a control with the right or middle mouse button does not trigger this event.
Clicks a control containing hyperlink data with the left mouse button. Clicking a control with the right or middle mouse button does not trigger this event. When the user moves the mouse pointer over a control containing hyperlink data, the mouse pointer changes to a hand icon. When the user clicks the mouse button, the hyperlink is activated, and then the Click event occurs.
When the user clicks the mouse button, the hyperlink is activated, and then the Click event occurs.
A Change event can cause a cascading event .
If you're trying to decide whether to use the Open or Load event for your macro or event procedure, one significant difference is that the Open event can be canceled, but the Load event can't. For example, if you're dynamically building a record source for a form in an event procedure for the form's Open event, you can cancel opening the form if there are no records to display.
If you're trying to decide whether to use the Open or Load event for your macro or event procedure, one significant difference is that the Open event can be canceled, but the Load event can't.
This occurs when a macro or event procedure that runs in response to the control's Change event alters the control's contents  for example, by changing a property setting that determines the control's value, such as the Text property for a text box.
To prevent a cascading event:
If possible, avoid attaching a Change macro or event procedure to a control that alters the control's contents.
Avoid creating two or more controls having Change events that affect each other  for example, two text boxes that update each other.
Changing the data in a text box or combo box by using the keyboard causes keyboard events to occur in addition to control events like the Change event. For example, if you move to a new record and type an ANSI character in a text box in the record, the following events occur in this order:
Changing the data in a text box or combo box by using the keyboard causes keyboard events to occur in addition to control events like the Change event.
The BeforeDelConfirm and AfterDelConfirm events don't occur and the Delete Confirm dialog box isn't displayed if you clear the Record Changes check box under Confirm on the Advanced tab of the Access Options dialog box, available by clicking the Microsoft Office Button and the clicking Access Options .
For example, if you move to a new record and type an ANSI character in a text box in the record, the following events occur in this order:
In combo boxes for which the LimitToList property is set to Yes, the NotInList event occurs after you enter a value that isn't in the list and attempt to move to another control or save the record.
The Dirty event occurs when the contents of the specified control changes.
The BeforeUpdate and AfterUpdate events for a record occur after you have entered the new or changed data in the record and moved to another record (or clicked Save Record on the Records menu), and therefore after the Dirty event for the record.
The Undo event for controls occurs whenever the user returns a control to its original state by clicking the Undo Field/Record button on the command bar, clicking the Undo button, pressing the ESC key, or calling the Undo method of the specified control. The control needs to have focus in all three cases. The event does not occur if the user clicks the Undo Typing button on the command bar.
KeyDown > KeyPress > BeforeInsert > Dirty > KeyUp
The BeforeUpdate and AfterUpdate events for the text box or combo box control occur after you have entered the new or changed data in the control and moved to another control (or clicked Save Record on the Records menu), and therefore after all of the Change events for the control.
In combo boxes for which the LimitToList property is set to Yes, the NotInList event occurs after you enter a value that isn't in the list and attempt to move to another control or save the record. It occurs after all the Change events for the combo box. In this case, the BeforeUpdate and AfterUpdate events for the combo box don't occur, because Microsoft Access doesn't accept a value that is not in the list.
In combo boxes for which the LimitToList property is set to Yes, the NotInList event occurs after you enter a value that isn't in the list and attempt to move to another control or save the record.
It occurs after all the Change events for the combo box.
In this case, the BeforeUpdate and AfterUpdate events for the combo box don't occur, because Microsoft Access doesn't accept a value that is not in the list.
Click Event
