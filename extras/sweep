#!/usr/bin/env python
import argparse
import os
import sys
from itertools import product

sys.path.insert(0, os.path.abspath(os.path.join(__file__, os.pardir, os.pardir)))

from cli import dependency
from cli.cluster import ClusterNode, DEFAULT_MMT_API_PORT
from cli.engine import MMTEngine
from cli.mt import BilingualCorpus
from cli.mt.processing import TrainingPreprocessor
from translator import BatchTranslator


class EngineConfigHelper:
    """Implements quirks to apply engine config to both 'engine.ini' and 'moses.ini'."""
    def __init__(self, engine, injector):
        """Call this with an initial 'engine' that has been properly loaded from disk and injected with param values."""
        self._engine = engine
        self._injector = injector
        self._params = {}
        self._types = {}

        # Obtain the current engine configuration (the subset which can be passed as options to `mmt create`),
        # which we will mostly recreate, except for the overrides in self._params:

        # self._injector_definitions[section] = injectable_fields
        # injectable_fields = { 'option': (description, type, default_value), ... }
        # e.g. { 'stack_size': ('search algorithm stack size', int, 1000), ... } -- for section='moses'
        self._injector_definitions = self._injector._definitions

        # load existing values from config
        config = self._engine.config
        for section, injectable_fields in self._injector_definitions.iteritems():
            for option, (desc, type, default_value) in injectable_fields.iteritems():
                if config.has_section(section) and config.has_option(section, option):
                    self._params['{}.{}'.format(section, option)] = config.get(section, option)
                    self._types['{}.{}'.format(section, option)] = type

        # these should be all which receive some special treatment, in addition to the regular config stuff
        self._source_lang = self._engine.config.get('engine', 'source_lang')
        self._target_lang = self._engine.config.get('engine', 'target_lang')
        self._weights = {k: self._engine.config.get('weights', k) for k in self._engine.config.options('weights')}
        self._name = self._engine.name

    def set(self, section, key, val):
        """set or override a specific section.key"""
        self._params['{}.{}'.format(section, key)] = val

    def arg_list(self):
        # must be compatible with the ArgumentParser() below in apply()
        arg_list = [self._source_lang, self._target_lang]
        for key, val in self._params.iteritems():
            if self._types[key] is bool:
                if (isinstance(val, bool) and val) or val == 'True':
                    # bool options are always-on if specified, regardless of what comes next
                    arg_list.append('--' + key)
                    arg_list.append('True')
            else:
                arg_list.append('--' + key)
                arg_list.append(str(val))
        return arg_list

    def write_engine_configs(self):
        """Write engine config using our param attributes, resembling 'mmt create' as much as possible."""
        parser = argparse.ArgumentParser()
        parser.add_argument('source_lang', metavar='SOURCE_LANGUAGE', help='the source language (ISO 639-1)')
        parser.add_argument('target_lang', metavar='TARGET_LANGUAGE', help='the target language (ISO 639-1)')
        for component in dependency.injectable_components:
            dependency.argparse_group(parser, component)

        # generate a fake argument list to code that works like 'mmt create'
        args = parser.parse_args(self.arg_list())

        # "do not touch any of these wires":
        injector = dependency.DependencyInjector()
        injector.read_args(args)

        engine = MMTEngine((args.source_lang, args.target_lang), self._name)
        engine = injector.inject(engine)

        engine.config.add_section('weights')
        for name, weights in self._weights.iteritems():
            engine.config.set('weights', name, weights)

        #print(self._name, ' '.join(self.arg_list()))
        engine.write_configs()

    def apply(self):
        self.write_engine_configs()
        # after this, call node.restart() for the new config to take effect


__desc_sweep = '''\
Parameter sweep: repeatedly translate a test set with different params

Legal SECTION.CONFIGKEY values are:

* engine.ini:
    [SECTION]
    CONFIGKEY = VALUE

* for moses.ini features:
    moses.ini is generated by MMT from engine.ini values, which you can set as above.
    See the options offered by  mmt create --help  for a list of available CONFIGKEYs.
    (Developers: see injectable_fields and get_iniline() in MosesFeature subclasses in cli/mt/)
'''

def main_sweep(argv):
    parser = argparse.ArgumentParser(description=__desc_sweep)
    parser.prog = 'mmt sweep'
    parser.add_argument('--path', dest='corpora_path', metavar='CORPORA', default=None,
                        help='the path to the test corpora (default is the automatically splitted sample)')
    parser.add_argument('-e', '--engine', dest='engine', help='the engine name, \'default\' will be used if absent',
                        default='default')
    parser.add_argument('--param', dest='params', nargs=2, action='append',
                        help='--param SECTION.CONFIGKEY \'VALUE_1 VALUE_2 ... VALUE_N\' specifies the sweep values')
    parser.add_argument('--dest', dest='dest_path', metavar='DEST', default=None,
                        help='the path to the output directory (created if it does not exist) - if given, writes '
                             'translation results in subdirectories named VALUE_x, in the --param order')
    parser.add_argument('-i', '--interactive', action='store_true', dest='interactive',
                        help='Test without sessions, as if translating sentence by sentence')
    parser.add_argument('-d', '--debug', action='store_true', dest='debug', help='if debug is set, it enables verbose '
                                                                                 'logging and prevents temporary files '
                                                                                 'to be removed after execution')

    args = parser.parse_args(argv)

    if args.params is None:
        print('at least one --param arg must be given.')
        sys.exit(1)

    # args.params = [[section_dot_key,values_str], ...]
    # transpose -> [(section_dot_key1, section_dot_key2, ...), (values1_str, values2_str, ...)]
    section_dot_keys, values_str = zip(*args.params)
    values = [vs.split(' ') for vs in values_str]
    # secs_keys = [[section1, key1], [section2, key2], ...]
    secs_keys = [sdk.split('.') for sdk in section_dot_keys]
    sections, keys = zip(*secs_keys)

    #_logconfig(False)

    engine = MMTEngine(name=args.engine)
    injector = dependency.DependencyInjector()
    injector.read_config(engine.config)
    engine = injector.inject(engine)
    node = ClusterNode(engine, api_port=DEFAULT_MMT_API_PORT)

    translator = BatchTranslator(node, use_sessions=not args.interactive)

    corpora = BilingualCorpus.list(args.corpora_path) if args.corpora_path is not None \
        else BilingualCorpus.list(os.path.join(node.engine.data_path, TrainingPreprocessor.TEST_FOLDER_NAME))

    # keep a copy of the original engine.ini around, so we can reset all params afterwards
    node.engine.backup_engine_config()

    try:
        # print TSV header
        for section, key in zip(sections, keys):
            sys.stdout.write('{}.{}\t'.format(section, key))
        sys.stdout.write('bleu\n')

        # Grid sweep of parameter value lists
        for grid_point in product(*values):
            # set grid_point parameters to node config
            cfg = EngineConfigHelper(node.engine, injector)
            for section, key, val in zip(sections, keys, grid_point):
                cfg.set(section, key, val)

            cfg.apply()
            node.restart()

            # build full dest_path directory name, based on parameter values
            dest_path = [args.dest_path]
            for section, key, val in zip(sections, keys, grid_point):
                dest_path.append(str(val))
            dest_path = os.path.join(*dest_path) if args.dest_path else None

            bleu = translator.translate(corpora=corpora, dest_path=dest_path, debug=args.debug)

            # print TSV line to stdout
            for section, key, val in zip(sections, keys, grid_point):
                sys.stdout.write('{}\t'.format(val))
            sys.stdout.write('{:.2f}\n'.format(bleu * 100.0))
    finally:
        node.engine.restore_engine_config()


if __name__ == '__main__':
    main_sweep(sys.argv[1:])
